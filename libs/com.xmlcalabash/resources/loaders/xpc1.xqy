xquery version "1.0" encoding "UTF-8";

(: This file was generated on Wed Jul 4, 2012 12:27 (UTC-05) by REx v5.16
   which is Copyright (c) 1979-2012 by Gunther Rademacher <grd@gmx.net> :)
(: REx command line: xpc.ebnf -xquery -tree -smaller :)

(: Lightly edited by ndw@nwalsh.com to make it a main module. :)

(:~
 : The parser that was generated for the xpc grammar.
 :)
declare namespace p="xpc";
declare default function namespace "http://www.w3.org/2005/xpath-functions";

(:~
 : The codepoint to charclass mapping for 7 bit codepoints.
 :)
declare variable $p:MAP0 as xs:integer+ :=
(
  50, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 4, 4, 4,
  5, 4, 4, 4, 4, 6, 7, 8, 4, 9, 10, 11, 11, 11, 11, 11, 11, 11, 11, 12, 4, 13, 14, 15, 16, 4, 17, 17, 17, 17, 17, 17,
  17, 17, 17, 17, 17, 18, 19, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 20, 17, 17, 21, 4, 22, 4, 17, 4, 23, 24, 25, 26,
  27, 28, 29, 30, 31, 17, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 4, 49, 4, 4
);

(:~
 : The codepoint to charclass mapping for codepoints below the surrogate block.
 :)
declare variable $p:MAP1 as xs:integer+ :=
(
  108, 124, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 156, 181, 181, 181, 181, 181, 214,
  215, 213, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214,
  214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214,
  214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214,
  214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 247, 261, 277, 308, 338, 324, 292,
  383, 419, 419, 419, 411, 367, 359, 367, 359, 367, 367, 367, 367, 367, 367, 367, 367, 367, 367, 367, 367, 367, 367,
  367, 367, 436, 436, 436, 436, 436, 436, 436, 352, 367, 367, 367, 367, 367, 367, 367, 367, 397, 419, 419, 420, 418,
  419, 419, 367, 367, 367, 367, 367, 367, 367, 367, 367, 367, 367, 367, 367, 367, 367, 367, 367, 367, 419, 419, 419,
  419, 419, 419, 419, 419, 419, 419, 419, 419, 419, 419, 419, 419, 419, 419, 419, 419, 419, 419, 419, 419, 419, 419,
  419, 419, 419, 419, 419, 419, 366, 367, 367, 367, 367, 367, 367, 367, 367, 367, 367, 367, 367, 367, 367, 367, 367,
  367, 367, 367, 367, 367, 367, 367, 367, 367, 367, 367, 367, 367, 367, 367, 367, 419, 50, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1,
  0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 4, 4, 4, 5, 4, 4, 4, 4, 6, 7, 8, 4, 23, 24, 25,
  26, 27, 28, 29, 30, 31, 17, 32, 33, 34, 35, 36, 9, 10, 11, 11, 11, 11, 11, 11, 11, 11, 12, 4, 13, 14, 15, 16, 17, 17,
  17, 17, 17, 17, 17, 17, 20, 17, 17, 21, 4, 22, 4, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 18, 19, 17, 17, 17, 17,
  17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 4, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 37, 38, 39,
  40, 41, 42, 43, 44, 45, 46, 47, 48, 4, 49, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 17, 17, 4, 4, 4, 4, 4, 4, 4, 11, 4, 4,
  4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11
);

(:~
 : The codepoint to charclass mapping for codepoints above the surrogate block.
 :)
declare variable $p:MAP2 as xs:integer+ :=
(
  57344, 63744, 64976, 65008, 65536, 63743, 64975, 65007, 65533, 1114111, 4, 17, 4, 17, 4
);

(:~
 : The token-set-id to DFA-initial-state mapping.
 :)
declare variable $p:INITIAL as xs:integer+ :=
(
  1, 2, 3, 4, 5, 1030, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
  32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60,
  61
);

(:~
 : The DFA transition table.
 :)
declare variable $p:TRANSITION as xs:integer+ :=
(
  4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233,
  4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233,
  4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 2434, 2433, 2433, 2438, 4233, 4233, 4233, 4233, 4233,
  4233, 4233, 4233, 4233, 4233, 4233, 2631, 4233, 4233, 4233, 4233, 4233, 2442, 4233, 4233, 4233, 4233, 4232, 4233,
  4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233,
  4233, 4560, 4233, 4233, 2470, 4233, 2451, 4233, 3609, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233,
  4233, 4233, 4233, 2592, 4233, 4233, 4233, 3188, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233,
  4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4536, 2559, 2456, 2463, 2462, 4233, 4233, 4233, 4233,
  4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 2598, 4233, 4233, 4233, 4233, 2591, 4233,
  4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233,
  4233, 4233, 2676, 4233, 4234, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233,
  4233, 4233, 4233, 4230, 4233, 4233, 4233, 4233, 3608, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233,
  4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 2604, 3448, 2565, 4233, 2467, 4233, 4233, 4233, 4233,
  4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 3190, 4233, 4233, 4233, 4229, 4233,
  4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233,
  4233, 4233, 4561, 4233, 4569, 2563, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233,
  4233, 4233, 4233, 2589, 4233, 4233, 4233, 4233, 3189, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233,
  4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 2479, 4233, 2965, 3227, 4070, 3234, 3234,
  4468, 4233, 2660, 3234, 3234, 3234, 2556, 3497, 2486, 2492, 2497, 2501, 2717, 2506, 3933, 2854, 3234, 2515, 2523,
  2529, 4409, 2739, 3924, 2806, 3310, 2761, 3234, 2533, 3235, 2541, 2547, 2553, 3234, 3213, 3643, 3234, 2569, 3234,
  4218, 4567, 2673, 4233, 4233, 3152, 4233, 4564, 3234, 3234, 2575, 4233, 4564, 3234, 3234, 2715, 4525, 2481, 3478,
  3234, 3234, 3234, 2740, 2667, 3234, 3234, 3234, 2598, 4073, 3234, 3234, 3719, 3234, 3234, 3273, 3234, 3234, 4093,
  3234, 3357, 3234, 4500, 2737, 3234, 3138, 3234, 3234, 3234, 3234, 2718, 4416, 4233, 4233, 3348, 4233, 2536, 3234,
  3643, 2581, 4233, 2536, 3234, 3234, 3137, 4069, 3230, 3234, 3234, 3234, 2747, 3187, 4072, 3234, 3234, 2716, 3394,
  3234, 3234, 4566, 2643, 3234, 3234, 2643, 3234, 2737, 4072, 3234, 4072, 2715, 2524, 3072, 3234, 3434, 3234, 3234,
  3234, 2737, 2475, 4562, 4233, 2844, 4519, 2642, 3234, 3234, 3988, 4233, 2642, 3234, 3234, 3234, 3494, 4233, 2722,
  3234, 3234, 3234, 4567, 2590, 3234, 3234, 3234, 2739, 3638, 3234, 3234, 2717, 4072, 3234, 2716, 4072, 3234, 2748,
  3234, 2716, 3234, 3320, 3234, 4507, 3298, 3234, 3234, 3234, 3234, 2748, 4324, 4233, 4233, 2966, 4233, 4071, 3234,
  3234, 4469, 4233, 4071, 3234, 3234, 3234, 3185, 2741, 3135, 3234, 3234, 3234, 2718, 3943, 3234, 3234, 3234, 2516,
  2524, 3234, 3234, 2740, 3234, 3234, 2739, 3234, 3234, 2534, 3234, 2542, 3234, 4464, 2715, 4073, 3644, 3234, 3234,
  3234, 3234, 4568, 2674, 4233, 4233, 2587, 4233, 3381, 3176, 3177, 2597, 4233, 3381, 3176, 3176, 2625, 2603, 3191,
  3176, 3176, 3176, 2610, 3497, 2608, 3176, 3176, 3382, 2599, 3176, 3176, 4153, 3173, 3176, 3176, 2615, 3176, 2624,
  4151, 3176, 2619, 3176, 3175, 2611, 3176, 2623, 3176, 3176, 3176, 2624, 2630, 2629, 2635, 2637, 2446, 4233, 4233,
  4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 3188, 4233, 4233, 4233, 4233,
  4231, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233,
  4233, 4233, 4233, 2959, 4233, 4233, 2561, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233,
  4233, 4233, 4233, 4233, 4233, 2591, 4233, 4233, 4233, 3187, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233,
  4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4325, 4233, 4233, 2473, 4233, 4233,
  4233, 4233, 2452, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 2641, 4233, 4233, 4233,
  3011, 4233, 4233, 4233, 3032, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233,
  4233, 4233, 4233, 4233, 2675, 4233, 4233, 2588, 4440, 4233, 4233, 3128, 4233, 4233, 4233, 4233, 4233, 4233, 4233,
  2647, 4233, 4233, 4233, 4233, 3498, 4233, 4233, 4233, 4233, 4438, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233,
  4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 2706, 3764, 4233, 4073, 4075, 4233, 3720,
  3234, 3234, 2783, 4233, 3133, 3234, 3234, 3234, 4067, 3228, 3232, 3234, 3234, 3234, 2749, 2652, 3234, 3234, 3234,
  4228, 3396, 3234, 3234, 4568, 2524, 3234, 4567, 2524, 3234, 3614, 3234, 2808, 3234, 4546, 3234, 3074, 4467, 3234,
  3234, 3234, 3234, 4285, 4289, 4563, 3234, 4517, 4233, 4094, 3234, 3136, 4525, 2480, 3477, 3234, 3234, 4466, 3496,
  2720, 3234, 3234, 3234, 3234, 4233, 2929, 3234, 3234, 3646, 3636, 3234, 3234, 2715, 4070, 3234, 3234, 2576, 3234,
  3234, 2936, 3234, 4180, 3234, 3322, 4505, 3234, 3300, 3234, 3234, 3234, 3234, 4318, 4322, 2535, 4283, 3226, 4233,
  4073, 3234, 4467, 4069, 3229, 3233, 3234, 3234, 3183, 4233, 3133, 3234, 3234, 3234, 3100, 2598, 2536, 3234, 3234,
  2748, 2518, 3234, 3234, 2738, 4564, 3234, 2737, 4564, 3234, 4566, 2536, 2737, 2536, 2747, 3234, 3212, 2715, 3234,
  3234, 3234, 3234, 4074, 4009, 2676, 2524, 2887, 4233, 4563, 3234, 3234, 3166, 4233, 2721, 3234, 3234, 3234, 2657,
  2480, 3477, 3234, 3234, 3234, 2739, 2666, 3234, 3234, 3234, 4568, 3469, 3234, 3234, 2749, 2536, 3234, 2748, 2536,
  3234, 4092, 3234, 3356, 3234, 4499, 3234, 3297, 3137, 3234, 3234, 3234, 3234, 2717, 4415, 4233, 4233, 2444, 4233,
  4233, 4233, 4233, 3446, 4233, 4233, 4233, 4233, 2677, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 3190, 4233, 4233,
  4233, 4229, 4233, 4233, 4233, 2672, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233,
  4233, 4233, 4233, 4233, 4233, 2690, 4233, 4233, 2915, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233,
  4233, 4233, 4233, 4233, 4233, 4233, 2589, 4233, 4233, 4233, 4233, 3189, 4233, 4233, 4233, 4233, 4233, 4233, 4233,
  4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 2593, 4319, 4323, 2681, 2683, 2687,
  3253, 2831, 2834, 2696, 4233, 2700, 3397, 3435, 4352, 3184, 2704, 2710, 2849, 2714, 3234, 2728, 2732, 2736, 2878,
  2991, 2749, 2519, 2998, 2746, 4221, 2754, 3234, 2758, 4565, 3234, 2488, 2767, 2772, 2776, 4463, 3122, 3213, 2781,
  3234, 2787, 3234, 2792, 2796, 4010, 2642, 3234, 2888, 4233, 4564, 3234, 3234, 3167, 4036, 2722, 3488, 3234, 2715,
  4525, 2481, 3478, 3234, 3234, 3234, 2740, 2667, 3234, 3234, 3234, 3605, 4073, 2502, 3234, 3719, 2871, 3234, 3273,
  3234, 3234, 2803, 3234, 4215, 3070, 4500, 2737, 3234, 3138, 3234, 3234, 3234, 3234, 2813, 3766, 3685, 2817, 3348,
  4233, 2536, 3234, 3643, 3186, 2821, 2825, 2972, 3234, 2838, 2842, 3230, 3120, 3234, 3486, 3981, 3187, 3388, 3234,
  2848, 2716, 3394, 3234, 2853, 4566, 2858, 2864, 2869, 2875, 4456, 2724, 4072, 3234, 4072, 2715, 2524, 3072, 3742,
  2882, 3234, 2892, 3234, 2896, 4287, 2905, 2909, 2912, 4519, 4527, 2921, 2919, 3714, 4233, 2482, 3234, 3234, 3234,
  3494, 4233, 2722, 4458, 2923, 3234, 4567, 2927, 3234, 2525, 3026, 2739, 3638, 3234, 3234, 2717, 4072, 2537, 2716,
  4072, 3234, 2934, 3234, 2716, 3234, 3320, 3234, 4507, 3298, 4306, 3234, 3234, 2940, 4316, 4320, 3403, 2945, 2948,
  2952, 2577, 2828, 3535, 2956, 2963, 3231, 2970, 3805, 2976, 3593, 2982, 2988, 2995, 3479, 3002, 3009, 3943, 3740,
  3755, 3234, 2750, 3015, 3024, 3519, 3030, 3036, 3040, 3044, 3901, 3051, 3896, 3055, 3061, 3067, 3951, 3079, 3083,
  3090, 4248, 3094, 3098, 3104, 4007, 4011, 3885, 3108, 3112, 4233, 4565, 3234, 3298, 3701, 4483, 2723, 3234, 3234,
  3643, 4526, 3475, 3234, 3234, 3234, 2737, 3497, 2668, 3234, 3117, 4566, 3467, 3234, 3234, 2747, 3720, 3414, 3234,
  3274, 3234, 2715, 4094, 3234, 3358, 3234, 2536, 3295, 3234, 3139, 3234, 3234, 3234, 4277, 3763, 3126, 4023, 4025,
  3349, 2447, 3234, 3234, 2782, 4233, 3132, 3234, 3144, 3234, 4066, 4233, 3231, 3234, 3234, 3234, 2748, 3188, 4073,
  3234, 3234, 2717, 3395, 3263, 3234, 4567, 4094, 3234, 4566, 4094, 3234, 2738, 4073, 4566, 4073, 4545, 3234, 3073,
  4466, 3234, 3234, 3234, 3234, 3149, 4288, 4233, 3156, 3159, 3707, 3853, 3234, 3163, 4432, 3171, 3476, 3234, 3234,
  3181, 3872, 3817, 2723, 3195, 3234, 3200, 4534, 3922, 3234, 3234, 3204, 3635, 2536, 3234, 3234, 2718, 4073, 3234,
  2717, 3209, 3234, 2935, 3234, 4179, 3234, 3321, 3234, 2524, 3299, 4543, 3234, 4345, 2768, 4317, 2583, 3217, 3221,
  3225, 3239, 2662, 3243, 3247, 3251, 3228, 3232, 3234, 3257, 3298, 4148, 2742, 3234, 2788, 3262, 3267, 4233, 3944,
  3454, 3234, 3271, 4381, 3541, 3234, 3278, 3284, 3234, 3289, 3961, 3234, 3234, 3293, 3304, 2543, 3234, 3308, 3314,
  3234, 3645, 3234, 3234, 3318, 3234, 4008, 4012, 4094, 4315, 3113, 4233, 3234, 3234, 3165, 4233, 2720, 3234, 3326,
  3234, 3995, 4233, 3476, 3234, 3331, 3234, 2738, 4229, 2524, 3234, 3234, 4567, 3468, 3234, 3234, 2748, 2535, 3234,
  2747, 2535, 3234, 2716, 2524, 2747, 2524, 4498, 3337, 3296, 3136, 3547, 3234, 3234, 3234, 4278, 3764, 4435, 3342,
  3346, 4233, 3720, 3234, 3234, 2783, 4233, 2984, 3354, 3362, 3371, 3378, 4554, 3232, 3140, 3234, 3931, 2749, 3386,
  2941, 2865, 3652, 3392, 3396, 3234, 3408, 3401, 3407, 3412, 4567, 2860, 3234, 3614, 3234, 2808, 3418, 4160, 3426,
  3074, 3432, 3234, 3234, 4262, 3234, 4285, 4289, 4520, 3439, 3443, 3833, 3452, 3234, 3458, 3462, 3473, 3483, 2511,
  3234, 3492, 3502, 2720, 3234, 3234, 3234, 3234, 4233, 3509, 3428, 3234, 3057, 3636, 3513, 3234, 2715, 4070, 3234,
  3234, 2576, 3518, 3523, 2936, 3234, 3529, 3533, 3539, 4505, 3234, 3300, 3234, 3545, 3551, 3556, 3560, 3564, 3568,
  3571, 3883, 2799, 4404, 3575, 3581, 4069, 3229, 3233, 3695, 3585, 3591, 2692, 3505, 3525, 3234, 4354, 2716, 2598,
  3597, 3145, 3234, 3602, 2518, 3196, 3234, 3613, 3619, 3234, 3623, 4564, 3234, 4566, 3627, 3632, 2536, 2493, 2777,
  3374, 3642, 3650, 3656, 3234, 3234, 3660, 3664, 3668, 3675, 3679, 3683, 3689, 3693, 4450, 3699, 3705, 4485, 3018,
  4407, 3234, 3996, 3671, 4138, 3234, 3234, 3020, 3280, 2666, 3234, 3234, 3577, 4470, 3469, 3234, 3711, 3718, 2509,
  3234, 2748, 3724, 3839, 4092, 3728, 2571, 3234, 3734, 3327, 3746, 3752, 3234, 3234, 3730, 3234, 3761, 3765, 3771,
  3775, 3779, 4233, 3783, 3789, 3748, 3793, 3799, 3809, 3338, 3234, 4429, 3815, 3229, 3821, 3825, 3899, 3234, 3831,
  2653, 3837, 3785, 2715, 3843, 3205, 3811, 3514, 4114, 3234, 3847, 3852, 3234, 3234, 3615, 3234, 2809, 3857, 4547,
  3552, 3234, 3863, 3234, 3827, 3234, 3234, 4286, 4290, 4564, 4277, 4518, 4233, 2524, 3737, 3137, 4526, 2481, 3478,
  3234, 3234, 3870, 4233, 2721, 3234, 3234, 3234, 4566, 2589, 4565, 3234, 3234, 2738, 3637, 3234, 3234, 2716, 4071,
  3234, 2715, 3795, 3598, 2747, 2930, 2715, 4565, 2737, 4073, 4506, 3234, 4073, 3234, 3234, 3234, 4315, 4319, 4323,
  3876, 3880, 2901, 4070, 3889, 3893, 3905, 3465, 3230, 3909, 3915, 3234, 3919, 4059, 3134, 3234, 3928, 3937, 2717,
  3942, 3086, 3234, 3948, 4241, 4383, 3955, 3848, 3960, 4565, 3911, 2738, 3965, 3971, 3976, 3967, 3333, 3980, 4463,
  3985, 3213, 3994, 3757, 4331, 4000, 3234, 4006, 4010, 3350, 4016, 4020, 4233, 3285, 3938, 4029, 4034, 4233, 2722,
  4040, 3234, 4002, 4046, 2481, 3478, 3234, 4052, 3234, 4057, 4063, 3420, 3234, 3422, 2598, 4073, 3258, 3234, 3719,
  3628, 3234, 3866, 4108, 4250, 4079, 3234, 4086, 4098, 4102, 4170, 3234, 4089, 2763, 4422, 3956, 4106, 3762, 4112,
  4048, 4118, 3348, 4122, 3063, 4128, 4131, 4135, 4124, 3135, 4142, 2978, 4157, 4069, 4164, 4168, 3234, 4453, 3587,
  2458, 3802, 4174, 3234, 4178, 4184, 4188, 4192, 4196, 4397, 4200, 3234, 4204, 3972, 4208, 4072, 3234, 4212, 4225,
  2524, 4238, 4245, 4254, 4260, 3234, 3234, 4266, 4287, 4291, 4270, 4272, 4519, 2642, 2549, 4030, 4082, 4233, 3475,
  4276, 3234, 4282, 3494, 4296, 4300, 4304, 3234, 4053, 4310, 2590, 3234, 4314, 3234, 2739, 3638, 3234, 4329, 2717,
  4072, 3234, 2716, 4072, 3234, 2748, 4335, 2716, 4042, 4339, 4343, 4349, 3367, 4512, 4358, 3234, 3234, 4316, 4362,
  4366, 4370, 4374, 4233, 4071, 3234, 3234, 4378, 4233, 3231, 3234, 3234, 3234, 3185, 2741, 3135, 3234, 3234, 3234,
  2718, 3943, 3234, 3234, 3234, 2516, 2524, 3234, 3234, 2740, 3234, 3234, 2739, 3234, 3234, 2534, 3234, 2542, 3234,
  4464, 2715, 4073, 3644, 3234, 3234, 3234, 3234, 4007, 3047, 4387, 4391, 4395, 4233, 4565, 3005, 4401, 4413, 2719,
  2723, 3234, 4420, 3643, 4526, 3475, 3234, 3234, 4426, 2737, 3497, 2668, 3234, 3234, 4566, 4444, 3234, 3234, 4462,
  3720, 3234, 3234, 3274, 3234, 2715, 4094, 3234, 3358, 4474, 2536, 3295, 3234, 3139, 3234, 3234, 3234, 4277, 4480,
  3767, 4489, 4493, 3349, 2447, 4497, 3234, 4145, 4233, 3504, 3234, 3234, 3234, 4066, 4233, 3231, 3234, 3234, 3234,
  2748, 3188, 4504, 3234, 3234, 2717, 3395, 3234, 3234, 4567, 4094, 3234, 4566, 4094, 3234, 2738, 4073, 4566, 4073,
  4545, 3234, 2885, 4256, 3234, 3234, 4511, 4476, 4284, 4288, 4233, 3234, 4516, 4233, 2643, 3234, 3234, 4524, 4233,
  3476, 3234, 3365, 3234, 3495, 2719, 2723, 3234, 3234, 3234, 4568, 4531, 3234, 3234, 3075, 3635, 2536, 3234, 4540,
  4551, 4073, 3234, 2717, 4447, 3234, 3990, 3234, 4179, 3234, 3321, 3234, 2524, 3299, 3234, 3234, 3234, 3234, 4317,
  4321, 3720, 3234, 2899, 4233, 4072, 3234, 4466, 4068, 3228, 3232, 3234, 3234, 3298, 3186, 3504, 3234, 3234, 3234,
  2715, 4233, 3944, 3234, 3234, 2747, 2517, 3234, 3234, 2737, 4563, 3234, 3234, 3961, 3234, 3859, 2535, 3234, 2543,
  3234, 4465, 3211, 3234, 3645, 3234, 3234, 3234, 3234, 4558, 4580, 4573, 4577, 2588, 4233, 4233, 4233, 4233, 4233,
  4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4229, 4233, 4233, 4233, 4233, 3607, 4233, 4233,
  4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233,
  2648, 4584, 4590, 4586, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233,
  4233, 4233, 3189, 4233, 4233, 4233, 3497, 4232, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233,
  4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4292, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233,
  4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233,
  4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233, 4233,
  2470, 4596, 4596, 4596, 4596, 4594, 4596, 4596, 4605, 4603, 4605, 5915, 4605, 4605, 4603, 4605, 4605, 4605, 6823,
  4611, 4605, 4605, 4605, 4782, 4607, 4622, 4605, 4605, 4635, 5883, 6920, 4605, 4605, 4605, 4861, 5887, 4605, 4633,
  4605, 4600, 4604, 4605, 4601, 4605, 4605, 4757, 4605, 6964, 4605, 4605, 4605, 4959, 4605, 5272, 4962, 4625, 4646,
  4646, 4605, 5024, 5699, 4646, 4646, 4646, 4979, 5769, 4646, 4646, 5803, 4651, 4646, 4646, 4646, 5071, 4605, 6459,
  4657, 6823, 6141, 4646, 4646, 6166, 4646, 4662, 5508, 4605, 4605, 5884, 6824, 4646, 6000, 4667, 6824, 4646, 4646,
  4646, 5292, 6005, 4646, 4646, 4682, 4713, 4646, 4605, 6823, 4646, 4646, 4646, 5304, 6380, 4646, 5507, 6823, 4646,
  4646, 4723, 6464, 4646, 4646, 4715, 4995, 4729, 4646, 4735, 4646, 4645, 6820, 4605, 4617, 4605, 4605, 4606, 4604,
  4605, 4605, 4629, 4604, 4740, 6622, 4646, 4646, 4921, 6824, 5505, 5506, 4605, 4605, 5505, 5330, 5507, 4790, 4605,
  4605, 4678, 4863, 6554, 4602, 4605, 4605, 4605, 5884, 4605, 4605, 4605, 4816, 4851, 4605, 4605, 4605, 5885, 4849,
  4853, 4605, 4605, 4605, 5888, 5886, 4848, 4850, 4850, 4850, 4852, 4850, 4853, 4605, 4847, 4850, 4853, 4848, 4850,
  4850, 4762, 4850, 4850, 4850, 4851, 4850, 6962, 4766, 4605, 4605, 4605, 5916, 4771, 4771, 4771, 4771, 4772, 4605,
  4787, 4605, 4605, 4605, 6824, 4646, 6028, 4605, 4605, 4605, 6944, 4605, 5883, 4605, 5505, 4646, 5506, 4646, 4858,
  4605, 4639, 4605, 5505, 5684, 4646, 4605, 5882, 5886, 6824, 4646, 4646, 4867, 4605, 4605, 4605, 6965, 4605, 4605,
  4605, 4869, 4963, 4878, 4878, 4878, 4880, 4884, 4893, 4605, 5359, 4605, 4670, 4605, 4605, 4805, 4605, 4646, 5787,
  5821, 6822, 4934, 4960, 4605, 6939, 4933, 4605, 4605, 4605, 4814, 4605, 4938, 6937, 4646, 5336, 4944, 4646, 4646,
  4646, 5506, 4605, 4605, 4605, 4961, 6936, 4646, 4646, 4646, 5199, 6914, 5506, 4605, 6574, 4950, 4958, 5885, 6075,
  4967, 4646, 4646, 4646, 5507, 4605, 4605, 4605, 4962, 5709, 5010, 4646, 4646, 4646, 5508, 4605, 4605, 6247, 6262,
  4646, 4646, 6298, 4646, 6343, 5016, 4605, 4707, 4646, 4646, 4697, 5130, 6374, 4646, 4646, 4646, 5637, 5029, 6427,
  5035, 6823, 5041, 4646, 4646, 4646, 5689, 5051, 4646, 5506, 4646, 6820, 4605, 6674, 4646, 4646, 4646, 5714, 6716,
  4646, 4646, 5056, 4646, 5823, 4817, 4605, 4758, 4605, 4841, 5506, 4605, 6129, 4646, 4695, 4646, 4646, 4605, 5505,
  4646, 6797, 4825, 6758, 4817, 5326, 5326, 5326, 5326, 5087, 5088, 4605, 5093, 6937, 4646, 5100, 4646, 4910, 5335,
  4646, 4914, 4918, 5006, 5294, 6287, 6940, 6812, 4646, 5503, 5157, 6195, 4605, 4605, 4605, 4814, 4606, 5168, 4646,
  4646, 4646, 5763, 5173, 4646, 4646, 4646, 5792, 4605, 6662, 6824, 4646, 6293, 4646, 5178, 4646, 4646, 4646, 5828,
  4646, 6253, 4646, 4646, 5076, 4646, 5183, 4605, 5188, 4646, 4973, 5633, 4988, 5504, 4646, 6656, 4646, 4976, 4646,
  4646, 6799, 4885, 4605, 5217, 6739, 5223, 5228, 6753, 4646, 4646, 6798, 4601, 4888, 4605, 6572, 4605, 5235, 4605,
  5240, 4889, 5249, 5253, 5253, 5253, 5257, 5259, 4606, 4604, 4605, 4873, 4683, 4646, 4646, 4684, 4646, 4646, 5139,
  4646, 5287, 4605, 5884, 4605, 4646, 4646, 6432, 4742, 4646, 5508, 4605, 4646, 4646, 5310, 4646, 4646, 4646, 5849,
  5319, 5319, 5319, 5319, 5322, 4601, 4888, 5353, 4605, 5564, 6854, 5732, 4646, 6822, 4605, 4776, 4605, 6963, 4605,
  5845, 4605, 4605, 4815, 4601, 4888, 6045, 5072, 4646, 4646, 5152, 4646, 5346, 6705, 4646, 4646, 5195, 4646, 5351,
  5357, 4605, 4962, 5818, 5393, 5363, 5331, 5372, 4646, 4994, 4999, 5927, 5373, 5377, 5382, 4646, 5005, 4646, 5614,
  5872, 5386, 5391, 4646, 5030, 5030, 5030, 6168, 4605, 4605, 4605, 4822, 4605, 5409, 5415, 5427, 4646, 5062, 4646,
  4646, 6107, 4646, 6033, 5433, 4646, 4646, 5298, 4646, 5439, 6184, 4605, 4605, 4834, 4605, 6908, 6272, 5444, 5124,
  4646, 6174, 4646, 6278, 5450, 4691, 4802, 4605, 4814, 6947, 6863, 5455, 5275, 4646, 5466, 5478, 6437, 4646, 4646,
  5315, 5507, 5482, 5487, 6823, 4646, 5219, 4646, 5493, 4646, 6504, 4646, 5082, 4646, 4646, 5036, 4646, 4646, 4646,
  5462, 6542, 4646, 6520, 5502, 6711, 4646, 5513, 4646, 5106, 4646, 6372, 5519, 5506, 5525, 5530, 5540, 5546, 4646,
  4990, 5551, 6925, 4646, 4646, 5494, 4605, 5558, 4646, 4646, 6771, 5020, 5020, 5020, 5020, 5562, 4885, 4605, 4605,
  4605, 4646, 5797, 6018, 4646, 5109, 4646, 4646, 5046, 4646, 4676, 4927, 4605, 4605, 4840, 4605, 4641, 4605, 4962,
  6937, 4646, 4646, 4646, 5503, 4646, 4646, 4646, 5387, 5573, 4646, 4646, 4646, 6016, 4748, 4646, 6798, 4605, 4816,
  4885, 4752, 5578, 5578, 5578, 5578, 5579, 4606, 4887, 4646, 5717, 4646, 4646, 5505, 6819, 4605, 4605, 4605, 5839,
  4605, 4605, 4847, 4850, 4850, 4850, 4850, 4849, 4646, 6415, 4646, 4646, 5505, 6820, 4605, 4605, 4605, 5883, 4605,
  4605, 4605, 4848, 5597, 4646, 4646, 4646, 6022, 5603, 4646, 4646, 5609, 5850, 4646, 4646, 4646, 6023, 5505, 5115,
  4646, 4646, 5506, 5505, 4646, 4646, 4940, 5643, 5645, 5650, 5649, 5649, 5651, 5655, 5659, 4601, 4888, 4605, 4605,
  4605, 4960, 4605, 6939, 4646, 4646, 4646, 4646, 4719, 5667, 4605, 5672, 5680, 5300, 5693, 5554, 5697, 5720, 5705,
  5418, 5703, 5052, 6822, 4605, 4605, 4902, 4909, 5174, 4646, 4646, 4646, 6086, 5781, 4646, 4646, 4646, 6118, 4646,
  5726, 4646, 5730, 4646, 5739, 4646, 5508, 4605, 6823, 4646, 4646, 6231, 4646, 5507, 6092, 4605, 6599, 4605, 4605,
  4646, 5267, 4646, 6226, 5761, 5767, 6408, 6561, 4646, 4646, 5507, 4646, 4646, 4646, 5505, 4646, 4646, 5773, 4646,
  4646, 6453, 5508, 6487, 4646, 4646, 5507, 4701, 5779, 4646, 5785, 6825, 4646, 5791, 4646, 4646, 5507, 5505, 4646,
  4646, 5411, 4646, 4646, 4646, 6151, 5796, 5133, 4646, 4646, 5507, 6823, 6498, 4646, 4646, 4646, 6206, 5662, 5811,
  5811, 5814, 5663, 5663, 4817, 4886, 4605, 4605, 4605, 5201, 4646, 5827, 4646, 4646, 5508, 6824, 4646, 4646, 4646,
  6209, 5446, 4646, 5136, 4646, 4646, 6818, 5505, 5832, 4646, 5394, 4646, 5145, 5505, 6530, 5503, 6417, 6822, 4605,
  4850, 4850, 4850, 4605, 5843, 5883, 4605, 5505, 5922, 4646, 5506, 6478, 4605, 5882, 5886, 4646, 4646, 4646, 5400,
  4646, 6097, 4605, 4605, 4952, 4954, 5025, 4646, 4646, 4646, 6236, 4646, 6159, 4646, 4646, 5568, 4646, 4646, 5854,
  4646, 4646, 5569, 4646, 4646, 5986, 4646, 5864, 4646, 4646, 5574, 5920, 6617, 4646, 5504, 4646, 4646, 4646, 5468,
  5876, 5876, 5876, 5876, 5877, 4606, 4887, 4605, 4868, 4605, 4605, 4778, 4605, 4783, 6824, 4646, 4646, 5584, 4646,
  4646, 6707, 4646, 6709, 5892, 6821, 5620, 4605, 4874, 4605, 4605, 5885, 5505, 4646, 4646, 5898, 4605, 4605, 4959,
  4605, 6938, 4646, 4646, 4646, 5381, 4605, 5904, 5909, 4646, 5162, 4646, 4646, 5061, 4646, 5224, 4646, 4646, 5504,
  6819, 4605, 4605, 4605, 5882, 4846, 5599, 4605, 4605, 4605, 4962, 6937, 5605, 5884, 5914, 4646, 5933, 5926, 4646,
  4646, 4646, 6257, 5931, 4646, 4646, 4646, 6267, 6310, 5937, 4646, 4646, 5722, 4646, 5506, 5942, 4646, 6443, 4646,
  5948, 4646, 4646, 5734, 5340, 5954, 5505, 4646, 4646, 5755, 4646, 4646, 6727, 4646, 4646, 5801, 4646, 5959, 4646,
  4646, 4646, 6282, 6805, 4646, 4646, 5283, 6799, 4605, 6760, 4896, 6966, 4678, 4982, 4896, 5509, 5965, 5977, 5977,
  5976, 5977, 5968, 5306, 5230, 4646, 4646, 5860, 4646, 5742, 5047, 5504, 5985, 4646, 5999, 4646, 4646, 5894, 5508,
  4646, 6004, 5505, 6820, 4984, 4605, 6009, 4646, 4646, 4646, 6308, 4646, 5938, 6038, 4605, 5066, 4605, 5885, 4605,
  4605, 4605, 4929, 5121, 4646, 5507, 4605, 5505, 4646, 6027, 6786, 4646, 6032, 4646, 6338, 4646, 6037, 6042, 4646,
  4646, 4646, 6327, 4646, 6052, 4646, 5507, 4605, 4605, 5883, 6823, 4646, 4646, 6547, 4646, 4646, 5506, 4646, 4646,
  4646, 5368, 5103, 6650, 4646, 4646, 5910, 4646, 5127, 4646, 4646, 6056, 6836, 4646, 5142, 4817, 4605, 6761, 4924,
  4814, 6965, 4905, 4904, 4605, 5288, 4605, 4959, 4827, 4829, 4829, 4830, 6062, 6064, 6068, 4885, 4605, 6074, 4605,
  4605, 5325, 5326, 4854, 4605, 6079, 5213, 5313, 5366, 4646, 4646, 5990, 4646, 4646, 6084, 6819, 4605, 5750, 4605,
  4605, 6090, 4605, 4605, 5489, 4605, 6113, 6103, 6117, 4646, 5263, 4685, 6821, 6122, 5508, 4605, 4605, 6823, 4646,
  6128, 4646, 4646, 4731, 4646, 6139, 4646, 4646, 6172, 4646, 4646, 6145, 6823, 4646, 5342, 5342, 4646, 5398, 4646,
  4646, 5211, 4646, 5507, 6525, 4646, 4646, 6188, 5506, 4646, 6157, 6163, 4646, 5404, 4646, 4646, 5278, 6447, 6780,
  6797, 4605, 6758, 4817, 4605, 4676, 4605, 4605, 5243, 5096, 4605, 4605, 5675, 5676, 5676, 5676, 6178, 6179, 6762,
  4886, 6856, 6183, 6823, 4646, 4646, 6235, 5833, 4646, 6189, 4646, 5042, 4646, 6193, 4605, 4605, 5505, 6360, 4605,
  5900, 4898, 4605, 5505, 6603, 4646, 5435, 6285, 5179, 6199, 6937, 4646, 4646, 6251, 4646, 6215, 6822, 4605, 4605,
  5593, 4961, 5905, 4646, 4646, 5347, 4646, 5757, 4646, 4646, 6297, 4646, 5508, 4613, 4605, 4605, 5881, 4605, 6224,
  6230, 4646, 4646, 6390, 6133, 6240, 4605, 6245, 4658, 6266, 4646, 4646, 4646, 6389, 6271, 4605, 4605, 6824, 5583,
  4646, 6276, 4646, 4646, 6395, 4646, 6830, 5504, 6291, 4646, 5440, 4605, 6823, 4646, 6302, 5504, 6819, 4605, 4808,
  4736, 6314, 6314, 6314, 6315, 6319, 6321, 4601, 5981, 4605, 4605, 5018, 5020, 6333, 4646, 4646, 5421, 6326, 6326,
  6325, 4646, 5472, 6888, 4646, 5078, 4646, 4646, 6385, 6304, 5012, 6331, 5011, 5589, 6012, 5057, 4646, 4646, 6399,
  6403, 5429, 4646, 6337, 6342, 6347, 5505, 6820, 4605, 5624, 4605, 4646, 4689, 4646, 4646, 6353, 6359, 4646, 5483,
  4646, 4646, 5526, 5547, 6211, 4646, 4646, 4646, 6463, 6364, 4605, 5885, 6823, 4646, 4646, 5744, 5855, 6058, 4646,
  5498, 4646, 6536, 6384, 4646, 4646, 4646, 6534, 6394, 5507, 4605, 4605, 4646, 6407, 6412, 4646, 4646, 6431, 4646,
  6421, 4646, 4646, 4646, 6678, 4646, 6425, 4605, 6823, 5268, 4646, 4646, 4646, 6685, 4646, 6436, 6515, 4646, 5503,
  4646, 5508, 4605, 6355, 6441, 4646, 5506, 4646, 6821, 6096, 4646, 6452, 4646, 4646, 6471, 5506, 6220, 4646, 4817,
  4605, 6761, 4605, 4814, 6965, 4605, 4605, 5203, 5203, 5203, 5205, 5207, 6457, 4885, 4605, 5627, 5628, 5628, 5628,
  4817, 6463, 4646, 4646, 4646, 6748, 5265, 6819, 4605, 4605, 5944, 4605, 4646, 6468, 4646, 4646, 6472, 4646, 5083,
  6821, 4605, 4605, 5971, 5972, 5775, 4646, 4646, 4646, 6775, 5507, 6476, 4605, 4605, 6070, 4605, 5882, 5886, 6482,
  4646, 5503, 4646, 6822, 4605, 4605, 4605, 5505, 4646, 4646, 4646, 4817, 4886, 5506, 6491, 6824, 4646, 5503, 4714,
  6821, 6497, 5508, 6502, 4646, 5503, 6529, 4646, 5506, 4605, 6824, 4646, 4646, 4725, 4646, 4646, 6508, 4709, 6823,
  6514, 6519, 4646, 6540, 4646, 4646, 6486, 4646, 4836, 4676, 4605, 4605, 6261, 6824, 5972, 5972, 5972, 5972, 5474,
  4605, 4605, 4605, 6569, 6578, 4946, 4646, 6546, 5687, 4945, 6048, 6047, 6551, 6560, 6565, 4605, 5710, 4646, 6101,
  6584, 5153, 5158, 4646, 5506, 5281, 6820, 5067, 5184, 4605, 4848, 4850, 4850, 4850, 4853, 4646, 6589, 6593, 4646,
  5506, 6824, 5859, 5668, 4960, 6597, 6939, 4646, 5735, 4646, 4646, 6524, 5507, 5950, 4646, 4646, 6609, 6615, 4646,
  5506, 4605, 4646, 4646, 4796, 5882, 5886, 6621, 6626, 4646, 6632, 6637, 6642, 4646, 4646, 6109, 6893, 4646, 4646,
  4793, 6147, 6153, 6648, 6654, 4605, 6660, 6666, 6672, 4969, 4646, 6349, 6684, 6689, 5505, 6693, 4646, 5508, 5245,
  4646, 4746, 6721, 4646, 4653, 4605, 6241, 4646, 6510, 6698, 5506, 4605, 4605, 5882, 5886, 4605, 4605, 4605, 4605,
  4602, 6605, 4646, 5955, 4646, 5508, 6080, 6493, 6702, 6715, 6720, 4646, 5534, 4646, 4646, 5423, 4646, 6725, 6644,
  4646, 4646, 6628, 5504, 6814, 6731, 4646, 4646, 6638, 5870, 4646, 6737, 4646, 6798, 4605, 6743, 6743, 6743, 6744,
  4606, 6752, 4646, 4646, 4646, 6797, 4605, 5521, 4646, 4646, 4646, 6798, 4605, 6759, 4605, 4605, 4677, 4605, 4605,
  4605, 6961, 5089, 4605, 4605, 6757, 6766, 6936, 4646, 5639, 4646, 6770, 4646, 4646, 6668, 4646, 4646, 6779, 4605,
  6784, 5961, 4646, 4646, 4646, 6799, 4605, 6760, 4605, 4605, 4678, 4605, 4605, 4605, 6964, 4605, 4646, 5995, 4646,
  4646, 6680, 6633, 4646, 6790, 4646, 6448, 6796, 4646, 5507, 6803, 4646, 6809, 4646, 4646, 6694, 4646, 4646, 6824,
  6611, 4646, 5536, 4646, 4646, 5001, 4646, 4646, 6585, 4646, 6834, 6760, 4605, 4605, 5236, 4605, 6840, 4605, 4753,
  6847, 6846, 6846, 6844, 6846, 6851, 4601, 4888, 5504, 4646, 6822, 4605, 5748, 5884, 6824, 6378, 5112, 5148, 6860,
  6949, 6869, 6951, 6876, 6867, 6873, 6880, 4885, 4605, 4605, 6882, 4646, 5461, 4646, 5458, 5505, 4646, 5231, 4646,
  5169, 4646, 4646, 6124, 4646, 5031, 4605, 4605, 4605, 6962, 4605, 4605, 6218, 5515, 4646, 4646, 6733, 4646, 5405,
  4646, 5866, 4646, 5542, 6203, 5503, 4646, 5588, 4605, 4818, 5807, 4605, 4845, 4605, 4605, 4767, 4605, 6886, 4605,
  5885, 5505, 4646, 6924, 4646, 5612, 4647, 4646, 5190, 5451, 4646, 5194, 4646, 4646, 5118, 4646, 6135, 4646, 4646,
  5508, 4646, 4646, 4646, 5504, 4646, 4605, 4605, 6580, 4646, 6892, 4646, 4646, 6792, 4646, 6556, 6758, 4817, 4605,
  5751, 4605, 4961, 6936, 5993, 4605, 6367, 6897, 6897, 6368, 6898, 6902, 4817, 4663, 4646, 4646, 4646, 6823, 4646,
  4646, 6906, 4646, 4646, 4646, 6824, 4646, 4646, 6912, 4646, 4646, 4646, 6829, 4646, 6797, 4606, 4887, 4605, 4605,
  4605, 5876, 5503, 4646, 6821, 4605, 4605, 4605, 5037, 4605, 5884, 6918, 4646, 5618, 4605, 4605, 4862, 4605, 5164,
  4646, 4646, 4646, 5632, 4646, 4646, 5506, 6824, 4646, 4646, 5506, 4605, 4799, 4605, 5837, 4605, 4960, 4605, 6935,
  4605, 4605, 6963, 4605, 4605, 4605, 4646, 4646, 4646, 4605, 4605, 4605, 4673, 6935, 6934, 4605, 6929, 6932, 6934,
  6932, 6935, 4618, 6935, 4703, 4605, 6957, 6956, 6956, 4605, 4603, 4813, 4811, 4811, 6955, 2054, 0, 2054, 2054, 2054,
  2054, 145, 0, 0, 66, 67, 0, 0, 0, 0, 66, 66, 0, 169, 0, 0, 0, 35840, 66, 10240, 0, 0, 97280, 66, 66, 66, 0, 0, 8458,
  355, 67, 67, 67, 67, 66, 6144, 0, 0, 0, 41984, 0, 259, 0, 0, 0, 48128, 259, 97, 97, 97, 97, 182, 97, 391, 97, 97, 0,
  526, 421, 349, 0, 0, 487, 470, 97, 97, 97, 185, 484, 485, 349, 0, 0, 10315, 0, 0, 11264, 0, 0, 9278, 10240, 0, 0, 504,
  97, 97, 97, 191, 97, 97, 97, 540, 97, 97, 0, 79872, 97, 551, 97, 97, 97, 45153, 0, 574, 0, 0, 0, 97280, 97, 580, 97,
  97, 97, 53345, 601, 97, 97, 97, 197, 97, 624, 625, 97, 627, 97, 642, 97, 97, 97, 59489, 97, 657, 97, 97, 97, 60513,
  648, 0, 0, 0, 111, 97, 720, 97, 97, 97, 64609, 97, 750, 97, 97, 97, 76897, 148, 0, 0, 0, 115, 69, 0, 0, 0, 164, 176,
  176, 0, 176, 63, 0, 0, 0, 170, 92, 92, 92, 92, 137, 0, 14336, 0, 0, 67, 10240, 15360, 0, 0, 0, 173, 348, 349, 5120, 0,
  0, 12288, 0, 0, 24576, 0, 0, 39936, 0, 0, 46080, 0, 0, 61440, 0, 0, 82944, 0, 0, 83968, 0, 0, 98304, 0, 0, 0, 9278, 0,
  0, 0, 86, 0, 348, 5120, 0, 64, 0, 0, 109, 109, 109, 123, 123, 0, 4096, 0, 0, 73, 0, 170, 0, 0, 0, 174, 348, 422, 0, 0,
  0, 176, 176, 176, 176, 0, 0, 0, 165, 97, 9454, 331, 0, 66, 0, 0, 0, 83, 13312, 0, 0, 0, 239, 0, 152, 0, 0, 0, 247, 98,
  98, 98, 98, 9278, 0, 146, 0, 66, 67, 7236, 0, 0, 0, 93, 7236, 0, 149, 0, 70, 0, 0, 255, 0, 0, 171, 0, 0, 80, 0, 80,
  175, 97, 97, 97, 200, 189, 97, 193, 195, 196, 97, 198, 97, 0, 638, 0, 71, 72, 0, 77, 0, 0, 232, 0, 336, 0, 0, 0, 257,
  260, 22528, 0, 0, 87, 0, 376, 97, 97, 97, 204, 97, 0, 415, 0, 0, 94, 94, 94, 101, 418, 0, 0, 0, 260, 0, 0, 0, 98, 97,
  429, 97, 97, 97, 81494, 97, 446, 447, 97, 0, 687, 97, 0, 84992, 0, 79, 0, 0, 334, 0, 97, 453, 97, 97, 97, 82017, 460,
  97, 97, 97, 207, 97, 464, 97, 97, 97, 83041, 498, 97, 97, 97, 208, 507, 97, 97, 97, 210, 97, 97, 571, 0, 0, 102, 102,
  102, 102, 608, 0, 0, 97, 537, 628, 97, 97, 97, 211, 9454, 635, 97, 0, 0, 97, 177, 641, 97, 97, 97, 218, 677, 97, 97,
  97, 225, 697, 97, 97, 97, 230, 755, 97, 97, 97, 278, 284, 97, 97, 97, 279, 477, 0, 0, 0, 335, 508, 97, 97, 97, 282,
  97, 545, 97, 97, 97, 87427, 649, 97, 97, 97, 283, 0, 251, 0, 0, 0, 337, 260, 0, 262, 0, 84, 0, 84, 273, 97, 275, 97,
  97, 28769, 97, 97, 30817, 97, 97, 32865, 97, 97, 33889, 97, 97, 34913, 97, 97, 47201, 97, 97, 55393, 97, 97, 63585,
  97, 97, 65633, 97, 97, 66657, 97, 97, 67681, 97, 97, 72801, 97, 97, 75873, 97, 97, 77921, 97, 97, 85089, 0, 89, 81,
  89, 289, 97, 97, 97, 288, 327, 97, 97, 97, 294, 97, 389, 97, 97, 97, 94305, 450, 97, 97, 97, 297, 502, 97, 97, 97,
  301, 541, 97, 97, 97, 310, 572, 0, 0, 0, 338, 0, 578, 97, 97, 97, 96353, 587, 97, 97, 97, 312, 97, 605, 0, 0, 112,
  112, 112, 112, 133, 133, 133, 133, 97, 700, 97, 97, 179, 182, 97, 727, 97, 97, 190, 97, 735, 97, 97, 97, 316, 97, 738,
  97, 97, 192, 97, 97, 74, 9278, 10240, 0, 78, 82, 0, 85, 0, 90, 0, 0, 640, 97, 93, 93, 93, 93, 100, 100, 100, 100, 128,
  128, 128, 128, 138, 9278, 191, 97, 0, 97, 184, 97, 97, 97, 644, 0, 8458, 267, 97, 97, 91233, 97, 97, 95329, 97, 185,
  97, 97, 763, 97, 50176, 0, 0, 0, 342, 97, 452, 97, 97, 193, 97, 97, 50273, 97, 97, 199, 97, 97, 558, 97, 97, 206, 97,
  97, 746, 747, 97, 187, 97, 97, 471, 97, 101, 101, 101, 101, 139, 9278, 0, 99, 99, 99, 99, 180, 97, 97, 97, 359, 201,
  97, 97, 97, 363, 228, 229, 97, 97, 213, 97, 311, 97, 97, 97, 367, 339, 340, 0, 0, 151, 0, 0, 343, 0, 0, 155, 156, 0,
  354, 8458, 97, 194, 97, 97, 474, 0, 360, 97, 97, 97, 369, 370, 97, 371, 372, 390, 97, 97, 97, 375, 396, 97, 97, 97,
  377, 97, 401, 97, 97, 271, 97, 97, 434, 435, 97, 97, 285, 97, 69729, 97, 97, 97, 386, 40960, 0, 97, 97, 286, 97,
  19553, 97, 25697, 97, 202, 230, 97, 205, 97, 97, 600, 97, 492, 493, 97, 97, 290, 97, 97, 62561, 97, 97, 299, 97,
  41057, 97, 0, 0, 573, 97, 544, 97, 97, 302, 97, 566, 97, 97, 97, 394, 592, 593, 79969, 97, 211, 97, 211, 97, 97, 97,
  29793, 97, 61537, 97, 97, 305, 97, 51200, 56320, 0, 0, 157, 0, 97, 617, 97, 619, 56417, 97, 97, 97, 397, 97, 636, 0,
  0, 158, 0, 645, 97, 97, 97, 409, 97, 663, 0, 664, 685, 97, 97, 0, 97, 97, 97, 0, 0, 0, 96, 97, 694, 97, 97, 306, 97,
  97, 702, 97, 97, 308, 97, 16481, 97, 97, 97, 436, 97, 709, 97, 711, 88161, 717, 97, 97, 313, 285, 68705, 70753, 97,
  97, 318, 319, 724, 97, 97, 97, 440, 97, 52321, 737, 97, 212, 97, 216, 749, 97, 89185, 90209, 102, 9278, 0, 0, 159, 0,
  548, 97, 97, 97, 441, 48225, 97, 97, 97, 443, 104, 104, 104, 104, 9278, 178, 97, 97, 97, 444, 221, 9454, 0, 0, 241, 0,
  346, 0, 84314, 97, 36961, 97, 97, 330, 9454, 97, 84065, 97, 97, 358, 97, 97, 404, 84372, 97, 219, 97, 97, 506, 97, 0,
  18432, 0, 0, 242, 0, 420, 348, 349, 0, 103, 103, 103, 103, 715, 97, 97, 97, 451, 97, 759, 97, 97, 361, 97, 87, 87, 95,
  95, 95, 105, 105, 118, 105, 105, 105, 129, 129, 129, 135, 129, 135, 140, 9278, 0, 106, 106, 106, 106, 153, 0, 0, 0,
  347, 161, 0, 163, 0, 110, 110, 110, 110, 0, 166, 0, 168, 181, 97, 186, 97, 220, 97, 97, 679, 97, 202, 97, 97, 209,
  217, 212, 97, 97, 365, 97, 231, 0, 181, 97, 97, 227, 353, 0, 8458, 97, 356, 379, 97, 381, 97, 221, 221, 97, 217, 97,
  97, 368, 97, 400, 97, 97, 403, 97, 407, 97, 0, 223, 97, 97, 97, 364, 97, 444, 468, 97, 225, 97, 97, 458, 97, 0, 480,
  0, 0, 244, 0, 0, 97, 496, 97, 97, 373, 97, 97, 563, 97, 97, 374, 97, 97, 567, 97, 97, 378, 97, 97, 621, 97, 97, 382,
  97, 97, 678, 97, 97, 384, 385, 97, 686, 97, 0, 233, 97, 742, 97, 97, 97, 455, 58465, 97, 97, 97, 456, 97, 714, 97, 97,
  388, 97, 88, 0, 88, 88, 106, 106, 122, 106, 122, 122, 106, 264, 0, 8458, 97, 237, 97, 97, 97, 78945, 277, 97, 97, 97,
  457, 309, 97, 97, 97, 461, 0, 341, 0, 0, 249, 0, 0, 417, 0, 0, 250, 0, 439, 97, 97, 97, 462, 647, 97, 97, 97, 463,
  667, 97, 97, 97, 466, 97, 676, 97, 97, 393, 97, 97, 745, 97, 97, 395, 97, 107, 107, 107, 107, 9278, 160, 0, 0, 0, 348,
  349, 0, 0, 0, 67, 0, 235, 224, 97, 97, 406, 97, 0, 248, 0, 0, 252, 253, 265, 8458, 97, 97, 357, 269, 97, 97, 97, 467,
  423, 0, 0, 0, 349, 0, 97, 445, 97, 97, 431, 97, 489, 97, 97, 97, 469, 97, 583, 97, 97, 432, 97, 596, 97, 97, 97, 472,
  0, 86016, 0, 0, 254, 0, 97, 652, 97, 97, 437, 97, 86113, 97, 0, 0, 688, 97, 739, 97, 97, 442, 97, 96, 96, 96, 108,
  141, 9278, 0, 113, 113, 113, 113, 126, 108, 108, 108, 108, 7236, 0, 0, 54272, 236, 97, 97, 97, 473, 292, 97, 295, 97,
  268, 97, 97, 512, 97, 307, 97, 97, 97, 494, 292, 97, 97, 97, 497, 0, 424, 0, 97, 272, 97, 274, 97, 449, 97, 97, 459,
  97, 501, 97, 97, 97, 499, 530, 0, 0, 0, 350, 539, 97, 97, 97, 500, 570, 97, 0, 0, 55296, 0, 609, 0, 97, 276, 97, 97,
  215, 97, 0, 97, 629, 97, 631, 97, 725, 97, 97, 465, 97, 127, 127, 130, 130, 130, 130, 142, 9278, 0, 0, 344, 0, 71680,
  0, 0, 0, 426, 172, 0, 0, 0, 479, 0, 234, 97, 97, 510, 97, 0, 246, 0, 0, 411, 0, 333, 0, 0, 0, 527, 97, 362, 97, 97,
  513, 97, 97, 398, 97, 97, 514, 97, 97, 509, 97, 511, 515, 97, 97, 97, 505, 97, 522, 97, 97, 516, 97, 577, 0, 0, 97,
  612, 97, 599, 97, 97, 517, 97, 97, 618, 97, 97, 538, 97, 97, 662, 97, 97, 543, 97, 97, 683, 97, 97, 547, 97, 97, 703,
  97, 97, 554, 97, 97, 706, 0, 97, 287, 97, 97, 408, 0, 740, 741, 97, 97, 556, 97, 110, 131, 131, 131, 131, 167, 0, 0,
  0, 529, 226, 97, 97, 203, 97, 226, 97, 9454, 0, 332, 0, 260, 0, 0, 263, 97, 321, 293, 97, 291, 293, 97, 296, 97, 97,
  392, 97, 97, 328, 319, 97, 300, 97, 97, 760, 97, 97, 433, 97, 97, 560, 97, 35937, 97, 97, 97, 519, 454, 97, 97, 97,
  521, 475, 0, 0, 0, 532, 0, 483, 0, 348, 349, 486, 97, 74849, 97, 97, 562, 97, 523, 97, 97, 525, 531, 0, 0, 0, 535,
  552, 97, 97, 97, 524, 568, 97, 97, 97, 542, 97, 651, 97, 97, 564, 97, 97, 23552, 0, 97, 304, 97, 97, 222, 97, 97,
  31841, 97, 97, 585, 97, 73825, 97, 97, 97, 546, 97, 322, 97, 97, 590, 97, 97, 594, 97, 97, 595, 97, 111, 111, 111,
  111, 132, 132, 132, 132, 132, 9278, 0, 210, 210, 97, 97, 97, 550, 210, 0, 97, 183, 97, 188, 298, 97, 97, 97, 565, 303,
  97, 97, 97, 569, 97, 323, 97, 97, 603, 97, 97, 380, 97, 97, 613, 97, 383, 97, 97, 97, 584, 414, 0, 416, 0, 117, 117,
  117, 121, 97, 438, 97, 97, 614, 615, 97, 490, 97, 97, 630, 97, 495, 97, 97, 97, 588, 518, 97, 97, 97, 597, 520, 97,
  97, 97, 602, 97, 555, 97, 557, 97, 559, 97, 561, 576, 0, 0, 0, 607, 579, 97, 581, 97, 314, 97, 97, 329, 97, 97, 589,
  97, 591, 97, 604, 97, 97, 633, 97, 620, 97, 97, 97, 622, 673, 97, 97, 97, 623, 97, 698, 97, 97, 646, 97, 719, 97, 97,
  97, 626, 736, 97, 97, 97, 634, 133, 9278, 0, 0, 419, 0, 214, 97, 97, 97, 648, 280, 97, 97, 283, 97, 97, 97, 650, 0,
  410, 0, 0, 476, 0, 0, 425, 97, 428, 586, 97, 97, 97, 668, 0, 606, 0, 0, 481, 0, 632, 97, 97, 97, 669, 0, 53248, 97,
  97, 654, 97, 97, 658, 97, 97, 656, 97, 666, 97, 97, 97, 680, 670, 97, 97, 97, 684, 682, 97, 97, 97, 690, 707, 97, 97,
  97, 692, 97, 49249, 97, 97, 671, 97, 97, 753, 97, 97, 675, 97, 215, 97, 97, 97, 696, 220, 97, 9454, 0, 144, 0, 0, 65,
  0, 240, 0, 0, 0, 611, 243, 0, 0, 245, 256, 0, 258, 0, 154, 0, 0, 413, 0, 260, 261, 0, 0, 482, 0, 281, 97, 97, 97, 722,
  320, 97, 97, 294, 324, 325, 0, 326, 0, 352, 0, 0, 528, 0, 21601, 430, 97, 97, 681, 97, 97, 448, 97, 97, 691, 97, 97,
  42081, 97, 97, 701, 97, 488, 97, 97, 97, 723, 97, 491, 97, 97, 705, 97, 43105, 97, 97, 97, 730, 57441, 97, 97, 97,
  743, 97, 503, 97, 97, 708, 97, 97, 549, 97, 97, 710, 97, 97, 553, 97, 97, 712, 713, 0, 575, 0, 0, 533, 0, 27648, 0,
  97, 97, 716, 97, 97, 582, 97, 97, 721, 97, 97, 80993, 97, 97, 726, 97, 28230, 97, 0, 0, 93184, 637, 0, 0, 639, 643,
  97, 97, 97, 744, 97, 659, 660, 661, 37985, 97, 693, 97, 315, 97, 97, 224, 97, 0, 97, 17505, 97, 695, 97, 97, 97, 748,
  699, 97, 97, 97, 754, 97, 92160, 97, 97, 729, 97, 97, 26721, 97, 97, 731, 97, 97, 758, 97, 97, 733, 734, 114, 114,
  114, 114, 9278, 197, 97, 97, 197, 270, 97, 97, 97, 756, 345, 0, 0, 0, 7236, 9278, 0, 0, 147, 0, 260, 0, 351, 366, 97,
  97, 97, 761, 399, 97, 97, 402, 405, 97, 97, 97, 762, 0, 412, 0, 0, 534, 0, 97, 616, 97, 97, 751, 97, 655, 97, 97, 97,
  9278, 0, 0, 0, 665, 97, 97, 752, 97, 672, 97, 674, 97, 317, 97, 97, 97, 92257, 704, 97, 97, 97, 9454, 0, 0, 0, 97, 97,
  689, 718, 97, 97, 97, 23649, 97, 728, 97, 97, 757, 97, 78, 0, 0, 78, 115, 115, 115, 115, 119, 115, 115, 119, 119,
  9278, 0, 162, 0, 0, 150, 0, 91, 0, 0, 76, 81, 0, 81, 124, 125, 116, 120, 116, 124, 134, 116, 136, 120, 120, 125, 125,
  143, 9278, 0, 0, 536, 97, 0, 478, 0, 0, 610, 97, 653, 97, 97, 97, 40033, 117, 121, 117, 117, 117, 121, 117, 121, 121,
  0, 427, 97, 97, 20577, 97, 97, 732, 97, 97, 22625, 97, 0, 29696, 0, 0, 6144, 67, 39009, 97, 97, 97, 44129, 97280,
  97280, 0, 97280, 97280, 97280, 97280, 0, 0, 0, 8458, 97, 97, 97, 198, 98304, 0, 0, 10240, 76, 0, 76, 116, 116, 120,
  124, 0, 98304, 98304, 98304, 98304, 0, 3072, 0, 0, 0, 10240, 0, 0, 0, 70
);

(:~
 : The DFA-state to expected-token-set mapping.
 :)
declare variable $p:EXPECTED as xs:integer+ :=
(
  287, 291, 297, 294, 301, 304, 305, 309, 316, 324, 441, 579, 330, 389, 389, 390, 389, 339, 312, 749, 346, 478, 352,
  356, 389, 389, 389, 371, 357, 361, 381, 751, 477, 365, 369, 389, 389, 389, 389, 333, 375, 379, 750, 522, 731, 387,
  389, 389, 389, 333, 394, 404, 470, 400, 388, 389, 389, 433, 464, 410, 505, 417, 389, 389, 434, 422, 413, 431, 389,
  389, 435, 439, 633, 389, 389, 335, 633, 389, 433, 445, 431, 389, 449, 634, 389, 397, 418, 389, 462, 389, 389, 389,
  389, 389, 389, 468, 619, 474, 499, 482, 486, 488, 492, 347, 496, 591, 503, 320, 509, 513, 519, 526, 530, 534, 540,
  544, 347, 843, 383, 548, 552, 347, 851, 572, 832, 565, 542, 596, 842, 348, 427, 561, 347, 347, 569, 576, 582, 589,
  595, 319, 514, 601, 563, 347, 677, 576, 839, 854, 842, 515, 605, 609, 719, 614, 630, 452, 618, 623, 609, 676, 780,
  627, 638, 642, 347, 777, 781, 554, 857, 458, 406, 554, 857, 458, 813, 610, 662, 811, 347, 653, 720, 659, 663, 670,
  663, 674, 674, 681, 682, 347, 347, 687, 326, 536, 693, 697, 701, 705, 709, 844, 715, 683, 748, 347, 655, 724, 728,
  827, 689, 645, 649, 666, 347, 347, 347, 514, 735, 739, 717, 824, 597, 647, 665, 347, 347, 347, 347, 425, 342, 743,
  718, 747, 711, 664, 457, 347, 347, 348, 755, 759, 347, 831, 557, 767, 347, 347, 769, 757, 761, 830, 585, 774, 347,
  769, 785, 762, 556, 456, 347, 770, 786, 763, 454, 347, 790, 794, 798, 347, 790, 802, 808, 768, 792, 804, 348, 817,
  821, 769, 793, 769, 836, 848, 861, 865, 869, 873, 404, 896, 1055, 933, 877, 879, 881, 934, 934, 885, 889, 934, 1022,
  883, 934, 886, 887, 887, 891, 891, 891, 891, 893, 893, 893, 895, 1054, 1123, 937, 918, 927, 928, 954, 937, 922, 968,
  937, 937, 1103, 926, 937, 937, 927, 1117, 1015, 905, 907, 923, 923, 977, 923, 1020, 937, 913, 915, 923, 924, 1201,
  1130, 920, 1119, 937, 937, 937, 937, 938, 1016, 958, 1010, 1012, 1014, 923, 923, 923, 916, 979, 990, 924, 1054, 922,
  1016, 983, 959, 1011, 1013, 923, 923, 923, 966, 923, 923, 978, 989, 923, 1054, 937, 1103, 937, 937, 939, 945, 1011,
  1019, 923, 923, 923, 923, 911, 923, 923, 989, 923, 923, 977, 972, 974, 986, 1010, 897, 1103, 937, 1089, 1118, 1071,
  908, 1103, 937, 1089, 937, 1188, 972, 985, 1010, 1019, 923, 923, 923, 988, 948, 937, 938, 935, 946, 1112, 1129, 1009,
  1018, 923, 923, 923, 976, 923, 923, 988, 948, 1088, 937, 921, 937, 923, 923, 1089, 972, 923, 976, 923, 1089, 1053,
  937, 937, 1064, 1047, 937, 937, 937, 1127, 923, 960, 923, 923, 923, 980, 923, 948, 937, 937, 946, 951, 996, 937, 1050,
  937, 946, 997, 902, 922, 1025, 1024, 981, 982, 1028, 1031, 1032, 1030, 1029, 1034, 1035, 1036, 1038, 1040, 995, 1132,
  937, 944, 1048, 1026, 1076, 909, 926, 937, 937, 950, 972, 1042, 956, 1045, 1058, 1061, 937, 937, 937, 939, 942, 1070,
  937, 1075, 937, 949, 941, 998, 1078, 903, 1080, 1082, 1133, 937, 937, 1085, 1087, 937, 937, 1050, 1006, 1007, 1132,
  937, 936, 1093, 937, 1095, 1001, 925, 942, 1113, 1098, 1058, 1100, 1062, 937, 937, 968, 937, 932, 937, 937, 970, 1115,
  1073, 999, 937, 937, 1051, 937, 1126, 937, 1089, 1102, 1108, 1110, 1082, 929, 1110, 1117, 937, 955, 901, 937, 922,
  992, 937, 932, 937, 1063, 1051, 944, 1048, 1089, 1090, 1122, 1095, 909, 937, 937, 937, 951, 1043, 1112, 1003, 1058,
  1113, 970, 1135, 998, 1000, 937, 937, 937, 952, 1088, 1090, 1052, 1117, 1068, 937, 937, 937, 1050, 940, 1137, 970,
  1073, 1055, 1089, 1122, 937, 991, 1050, 937, 973, 1010, 1019, 923, 1068, 937, 937, 933, 942, 1003, 1139, 951, 937,
  937, 1055, 932, 1048, 937, 937, 953, 970, 937, 937, 1105, 1177, 1118, 937, 937, 1003, 971, 937, 937, 937, 1071, 1066,
  937, 1127, 937, 1118, 1003, 1126, 970, 937, 937, 1126, 1088, 1102, 1127, 1004, 937, 937, 937, 1072, 1188, 1143, 937,
  937, 1193, 937, 899, 1056, 1146, 1148, 1083, 1150, 1152, 1154, 1156, 1158, 1160, 1162, 1164, 1166, 1168, 1170, 1172,
  1174, 937, 951, 937, 1005, 1050, 1005, 937, 1049, 937, 937, 937, 1126, 937, 1180, 1182, 1185, 1187, 1144, 1190, 937,
  937, 1016, 983, 959, 1207, 1091, 1195, 919, 1120, 1096, 993, 1197, 1121, 1062, 994, 1047, 1071, 1067, 937, 937, 937,
  1089, 937, 937, 945, 947, 930, 1130, 963, 1121, 902, 1204, 937, 937, 1063, 968, 1072, 937, 937, 937, 1206, 947, 931,
  1065, 937, 937, 937, 1126, 1088, 1191, 1117, 937, 1071, 1141, 931, 1131, 1120, 902, 1204, 937, 1206, 947, 962, 964,
  969, 1047, 937, 1064, 937, 1064, 1047, 964, 969, 1047, 1063, 1183, 937, 968, 1063, 1047, 937, 1127, 937, 898, 937,
  992, 1043, 961, 963, 902, 1046, 937, 1047, 937, 1199, 1067, 937, 1106, 1175, 937, 1071, 937, 937, 937, 1178, 1202,
  1104, 1004, 922, 992, 1051, 937, 967, 937, 937, 937, 943, 1202, 1104, 1004, 1127, 937, 1005, 1089, 1095, 897, 937,
  953, 970, 1047, 1124, 1021, 937, 1128, 1209, 1104, 1128, 1209, 1059, 1124, 1128, 1125, 1124, 1128, 1002, 1002, 6, 34,
  66, 258, 2050, 8194, 16898, 4098, 4194306, 2, 337641530, 337641530, 12582914, 2, -350388070, -350388070, -346193766,
  -346193766, -8547142, 256, 4096, 0, -2147483648, -2147409920, 69206016, 268435456, 0, 864, 1835136, 184549504,
  -536870784, 128, 4096, 256, 128, 188743808, 4120, 257949824, -268435328, 128, 4104, 8388608, 16384, 3145728, 12582912,
  0, 128, 128, 256, 16384, 0, 32, 64, 256, 7168, 8192, 0, 2, 2, 4, 0, 0, 1, 2, 16, 16, 32, 0, 4, 8, 16, 128, 0, 8,
  67108864, 0, 16, 2048, 0, 24, 544, 1572992, 16777344, 33554560, 128, 7168, 2097152, 12582912, 268435456, 20971648,
  128, 524288, 0, 32768, 262144, 0, 32896, 65664, 262272, 128, 4194432, 128, 2097280, 201326720, 128, 524416, 524416,
  1048704, 65664, 524416, 16777344, 128, 201326720, 268435584, 128, 786432, 0, 49152, 131072, 1048576, 2097152,
  67108864, 268435456, 536870912, 0, 4096, 2048, 32768, 0, 8192, 1073872896, -2147418112, 65664, 33554560, 134217856,
  536871040, 1073741952, -2147483520, 128, 98432, 262272, 134217856, 1073741952, 128, 4194304, 8388608, 290, 16640,
  16640, 4194304, 134217792, 524416, 931457599, 927246911, 931458623, 931457599, 931457599, 927312447, 935651903,
  -5969025, -5969025, -5968001, -5969025, -5968001, -1249281, 3, 4, 16, 26624, 32768, 33554432, 0, 65536, 0, 131072,
  2097152, 134217728, 4096, 131072, 0, -2146697216, 262144, 8388608, 1024, 117440512, 805306368, 0, 262144, 524288,
  33554432, 917504, 0, 524288, 1568, 0, 786432, 33554432, 67108864, 10240, 4194304, 134352896, 327680, 12582912,
  10485760, 251658240, 1879048192, -2147483648, -2147352576, 2016, 786432, 14680064, 0, 4194304, 0, 64, 384, 65536,
  4194304, 64, 134217728, 805306368, 24576, 32768, 50331648, 67108864, 327680, 0, 8388608, 0, 31, 16515072, 64, 768,
  2097152, 201326592, 32, 512, 2048, 8388608, 16777216, 1073741824, -2147483648, 0, 12582912, 16777216, 134217728, 0,
  2048, 4096, 1024, 0, 1024, 2048, 8192, 16384, 2097152, 0, 1888, 8388608, 33554432, 32, 2048, 262144, 33554432, 131072,
  4194304, 1073741824, 0, 15794176, -2113855488, -1072955392, -1072824320, -2147483648, -1073741824, -1073610752,
  972062687, 972062687, 972095455, 972193759, 1005617119, -1175355425, 2045804511, 2045837279, 1005748191, -101613601,
  2045935583, 2045968351, -101482529, -101482529, -68059169, -67928097, -1175420961, -1175289889, -100892705, -68091937,
  -100761633, -67960865, -67239969, 0, 16646144, 64, 896, 786432, 31744, 15728640, 956301312, 0, 33554432, 64512,
  15859712, 989855744, 0, 67108864, 15925248, 0, 134217728, 16580608, 0, 512, 15360, 131072, 33554432, 1, 786432, 512,
  7168, 4194304, 49152, 33554432, 1, 4, 24, 4096, 4194304
);

(:~
 : The token-string table.
 :)
declare variable $p:TOKEN as xs:string+ :=
(
  "EPSILON",
  "S",
  "EOF",
  "comment",
  "pi",
  "quotedstr",
  "NCName",
  "CName",
  "QName",
  "Char",
  "','",
  "'1.0'",
  "'<![XML['",
  "'='",
  "']]>'",
  "'add-attribute'",
  "'add-xml-base'",
  "'catch'",
  "'choose'",
  "'compare'",
  "'count'",
  "'data'",
  "'declare-step'",
  "'default'",
  "'delete'",
  "'directory-list'",
  "'document'",
  "'documentation'",
  "'empty'",
  "'error'",
  "'escape-markup'",
  "'exec'",
  "'filter'",
  "'for-each'",
  "'group'",
  "'hash'",
  "'http-request'",
  "'identity'",
  "'import'",
  "'inline'",
  "'input'",
  "'insert'",
  "'iteration-source'",
  "'label-elements'",
  "'library'",
  "'load'",
  "'log'",
  "'make-absolute-uris'",
  "'named'",
  "'namespace'",
  "'namespace-rename'",
  "'namespaces'",
  "'on'",
  "'option'",
  "'otherwise'",
  "'output'",
  "'pack'",
  "'parameters'",
  "'pipeinfo'",
  "'pipeline'",
  "'rename'",
  "'replace'",
  "'required'",
  "'serialization'",
  "'set-attributes'",
  "'sink'",
  "'split-sequence'",
  "'store'",
  "'string-replace'",
  "'to'",
  "'try'",
  "'unescape-markup'",
  "'unwrap'",
  "'uuid'",
  "'validate-with-relax-ng'",
  "'validate-with-schematron'",
  "'validate-with-xml-schema'",
  "'variable'",
  "'viewport'",
  "'viewport-source'",
  "'when'",
  "'with'",
  "'with-option'",
  "'with-param'",
  "'wrap'",
  "'wrap-sequence'",
  "'www-form-urldecode'",
  "'www-form-urlencode'",
  "'xinclude'",
  "'xpath-context'",
  "'xproc'",
  "'xquery'",
  "'xsl-formatter'",
  "'xslt'",
  "'{'",
  "'}'"
);

(:~
 : Match next token in input string, starting at given index, using
 : the DFA entry state for the set of tokens that are expected in
 : the current context.
 :
 : @param $input the input string.
 : @param $begin the index where to start in input string.
 : @param $token-set the expected token set id.
 : @return a sequence of three: the token code of the result token,
 : with input string begin and end positions. If there is no valid
 : token, return the negative id of the DFA state that failed, along
 : with begin and end positions of the longest viable prefix.
 :)
declare function p:match($input as xs:string,
                         $begin as xs:integer,
                         $token-set as xs:integer) as xs:integer+
{
  let $result := $p:INITIAL[1 + $token-set]
  return p:transition($input,
                      $begin,
                      $begin,
                      $begin,
                      $result,
                      $result mod 1024,
                      0)
};

(:~
 : The DFA state transition function. If we are in a valid DFA state, save
 : it's result annotation, consume one input codepoint, calculate the next
 : state, and use tail recursion to do the same again. Otherwise, return
 : any valid result or a negative DFA state id in case of an error.
 :
 : @param $input the input string.
 : @param $begin the begin index of the current token in the input string.
 : @param $current the index of the current position in the input string.
 : @param $end the end index of the result in the input string.
 : @param $result the result code.
 : @param $current-state the current DFA state.
 : @param $previous-state the  previous DFA state.
 : @return a sequence of three: the token code of the result token,
 : with input string begin and end positions. If there is no valid
 : token, return the negative id of the DFA state that failed, along
 : with begin and end positions of the longest viable prefix.
 :)
declare function p:transition($input as xs:string,
                              $begin as xs:integer,
                              $current as xs:integer,
                              $end as xs:integer,
                              $result as xs:integer,
                              $current-state as xs:integer,
                              $previous-state as xs:integer) as xs:integer+
{
  if ($current-state = 0) then
    let $result := $result idiv 1024
    return
      if ($result != 0) then
      (
        $result - 1,
        $begin,
        $end
      )
      else
      (
        - $previous-state,
        $begin,
        $current - 1
      )
  else
    let $c0 := (string-to-codepoints(substring($input, $current, 1)), 0)[1]
    let $c1 :=
      if ($c0 < 128) then
        $p:MAP0[1 + $c0]
      else if ($c0 < 55296) then
        let $c1 := $c0 idiv 16
        let $c2 := $c1 idiv 32
        return $p:MAP1[1 + $c0 mod 16 + $p:MAP1[1 + $c1 mod 32 + $p:MAP1[1 + $c2]]]
      else
        p:map2($c0, 1, 5)
    let $current := $current + 1
    let $i0 := 763 * $c1 + $current-state - 1
    let $i1 := $i0 idiv 4
    let $i2 := $i1 idiv 4
    let $next-state := $p:TRANSITION[$i0 mod 4 + $p:TRANSITION[$i1 mod 4 + $p:TRANSITION[$i2 + 1] + 1] + 1]
    return
      if ($next-state > 1023) then
        p:transition($input, $begin, $current, $current, $next-state, $next-state mod 1024, $current-state)
      else
        p:transition($input, $begin, $current, $end, $result, $next-state, $current-state)
};

(:~
 : Recursively translate one 32-bit chunk of an expected token bitset
 : to the corresponding sequence of token strings.
 :
 : @param $result the result of previous recursion levels.
 : @param $chunk the 32-bit chunk of the expected token bitset.
 : @param $base-token-code the token code of bit 0 in the current chunk.
 : @return the set of token strings.
 :)
declare function p:token($result as xs:string*,
                         $chunk as xs:integer,
                         $base-token-code as xs:integer) as xs:string*
{
  if ($chunk = 0) then
    $result
  else
    p:token
    (
      ($result, if ($chunk mod 2 != 0) then $p:TOKEN[$base-token-code] else ()),
      if ($chunk < 0) then $chunk idiv 2 + 2147483648 else $chunk idiv 2,
      $base-token-code + 1
    )
};

(:~
 : Calculate expected token set for a given DFA state as a sequence
 : of strings.
 :
 : @param $state the DFA state.
 : @return the set of token strings
 :)
declare function p:expected-token-set($state as xs:integer) as xs:string*
{
  if ($state > 0) then
    for $t in 0 to 2
    let $i0 := $t * 763 + $state - 1
    let $i1 := $i0 idiv 2
    let $i2 := $i1 idiv 4
    return p:token((), $p:EXPECTED[$i0 mod 2 + $p:EXPECTED[$i1 mod 4 + $p:EXPECTED[$i2 + 1] + 1] + 1], $t * 32 + 1)
  else
    ()
};

(:~
 : Classify codepoint by doing a tail recursive binary search for a
 : matching codepoint range entry in MAP2, the codepoint to charclass
 : map for codepoints above the surrogate block.
 :
 : @param $c the codepoint.
 : @param $lo the binary search lower bound map index.
 : @param $hi the binary search upper bound map index.
 : @return the character class.
 :)
declare function p:map2($c as xs:integer, $lo as xs:integer, $hi as xs:integer) as xs:integer
{
  if ($lo > $hi) then
    0
  else
    let $m := ($hi + $lo) idiv 2
    return
      if ($p:MAP2[$m] > $c) then
        p:map2($c, $lo, $m - 1)
      else if ($p:MAP2[5 + $m] < $c) then
        p:map2($c, $m + 1, $hi)
      else
        $p:MAP2[10 + $m]
};

(:~
 : The index of the parser state for accessing the combined
 : (i.e. level > 1) lookahead code.
 :)
declare variable $p:lk := 1;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the begin of the token that has been shifted.
 :)
declare variable $p:b0 := 2;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the end of the token that has been shifted.
 :)
declare variable $p:e0 := 3;

(:~
 : The index of the parser state for accessing the code of the
 : level-1-lookahead token.
 :)
declare variable $p:l1 := 4;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the begin of the level-1-lookahead token.
 :)
declare variable $p:b1 := 5;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the end of the level-1-lookahead token.
 :)
declare variable $p:e1 := 6;

(:~
 : The index of the parser state for accessing the token code that
 : was expected when an error was found.
 :)
declare variable $p:error := 7;

(:~
 : The index of the parser state that points to the first entry
 : used for collecting action results.
 :)
declare variable $p:result := 8;

(:~
 : Create a textual error message from a parsing error.
 :
 : @param $input the input string.
 : @param $error the parsing error descriptor.
 : @return the error message.
 :)
declare function p:error-message($input as xs:string, $error as element(error)) as xs:string
{
  let $begin := xs:integer($error/@b)
  let $context := string-to-codepoints(substring($input, 1, $begin - 1))
  let $linefeeds := index-of($context, 10)
  let $line := count($linefeeds) + 1
  let $column := ($begin - $linefeeds[last()], $begin)[1]
  return
    if ($error/@o) then
      concat
      (
        "syntax error, found ", $p:TOKEN[$error/@o + 1], "&#10;",
        "while expecting ", $p:TOKEN[$error/@x + 1], "&#10;",
        if ($error/@e = $begin) then
          ""
        else
          concat("after successfully scanning ", string($error/@e - $begin), " characters "),
        "at line ", string($line), ", column ", string($column), "&#10;",
        "...", substring($input, $begin, 32), "..."
      )
    else
      let $expected := p:expected-token-set($error/@s)
      return
        concat
        (
          "lexical analysis failed&#10;",
          "while expecting ",
          "["[exists($expected[2])],
          string-join($expected, ", "),
          "]"[exists($expected[2])],
          "&#10;",
          if ($error/@e = $begin) then
            ""
          else
            concat("after successfully scanning ", string($error/@e - $begin), " characters "),
          "at line ", string($line), ", column ", string($column), "&#10;",
          "...", substring($input, $begin, 32), "..."
        )
};

(:~
 : Shift one token, i.e. compare lookahead token 1 with expected
 : token and in case of a match, shift lookahead tokens down such that
 : l1 becomes the current token, and higher lookahead tokens move down.
 : When lookahead token 1 does not match the expected token, raise an
 : error by saving the expected token code in the error field of the
 : parser state.
 :
 : @param $code the expected token.
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:shift($code as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else if ($state[$p:l1] = $code) then
  (
    subsequence($state, $p:l1, $p:e1 - $p:l1 + 1),
    0,
    $state[$p:e1],
    subsequence($state, $p:e1),
    if ($state[$p:e0] != $state[$p:b1]) then
      text {substring($input, $state[$p:e0], $state[$p:b1] - $state[$p:e0])}
    else
      (),
    let $name := $p:TOKEN[1 + $state[$p:l1]]
    let $content := substring($input, $state[$p:b1], $state[$p:e1] - $state[$p:b1])
    return
      if (starts-with($name, "'")) then
        element TOKEN {$content}
      else
        element {$name} {$content}
  )
  else
  (
    subsequence($state, 1, $p:error - 1),
    element error
    {
      attribute b {$state[$p:b1]},
      attribute e {$state[$p:e1]},
      if ($state[$p:l1] < 0) then
        attribute s {- $state[$p:l1]}
      else
        (attribute o {$state[$p:l1]}, attribute x {$code})
    },
    subsequence($state, $p:error + 1)
  )
};

(:~
 : Use p:match to fetch the next token, but skip any leading
 : whitespace.
 :
 : @param $input the input string.
 : @param $begin the index where to start.
 : @param $token-set the valid token set id.
 : @return a sequence of three values: the token code of the result
 : token, with input string positions of token begin and end.
 :)
declare function p:matchW($input as xs:string,
                          $begin as xs:integer,
                          $token-set as xs:integer) as xs:integer+
{
  let $match := p:match($input, $begin, $token-set)
  return
    if ($match[1] = 1) then                                 (: S :)
      p:matchW($input, $match[3], $token-set)
    else
      $match
};

(:~
 : Lookahead one token on level 1 with whitespace skipping.
 :
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:lookahead1W($set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:l1] != 0) then
    $state
  else
    let $match := p:matchW($input, $state[$p:b1], $set)
    return
    (
      $match[1],
      subsequence($state, $p:lk + 1, $p:l1 - $p:lk - 1),
      $match,
      subsequence($state, $p:e1 + 1)
    )
};

(:~
 : Lookahead one token on level 1.
 :
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:lookahead1($set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:l1] != 0) then
    $state
  else
    let $match := p:match($input, $state[$p:b1], $set)
    return
    (
      $match[1],
      subsequence($state, $p:lk + 1, $p:l1 - $p:lk - 1),
      $match,
      subsequence($state, $p:e1 + 1)
    )
};

(:~
 : Reduce the result stack. Pop $count element, wrap them in a
 : new element named $name, and push the new element.
 :
 : @param $state the parser state.
 : @param $name the name of the result node.
 : @param $count the number of child nodes.
 : @return the updated parser state.
 :)
declare function p:reduce($state as item()+, $name as xs:string, $count as xs:integer) as item()+
{
  subsequence($state, 1, $count),
  element {$name}
  {
    subsequence($state, $count + 1)
  }
};

(:~
 : Parse the 1st loop of production libraryBody (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-libraryBody-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(26, $input, $state)         (: S | 'declare-step' | 'import' | 'pipeline' | '}' :)
    return
      if ($state[$p:l1] = 95) then                          (: '}' :)
        $state
      else
        let $state :=
          if ($state[$p:l1] = 38) then                      (: 'import' :)
            let $state := p:parse-imports($input, $state)
            return $state
          else if ($state[$p:l1] = 22) then                 (: 'declare-step' :)
            let $state := p:parse-declareStep($input, $state)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:parse-pipeline($input, $state)
            return $state
        return p:parse-libraryBody-1($input, $state)
};

(:~
 : Parse libraryBody.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-libraryBody($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(4, $input, $state)             (: '{' :)
  let $state := p:shift(94, $input, $state)                 (: '{' :)
  let $state := p:parse-libraryBody-1($input, $state)
  let $state := p:shift(95, $input, $state)                 (: '}' :)
  return p:reduce($state, "libraryBody", $count)
};

(:~
 : Parse library.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-library($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(44, $input, $state)                 (: 'library' :)
  let $state := p:lookahead1W(23, $input, $state)           (: S | 'with' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 81) then                       (: 'with' :)
      let $state := p:parse-withExtra($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(5, $input, $state)            (: EPSILON | S :)
  let $state := p:parse-libraryBody($input, $state)
  return p:reduce($state, "library", $count)
};

(:~
 : Parse the 1st loop of production withParamBody (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-withParamBody-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(34, $input, $state)         (: S | comment | pi | quotedstr | 'data' | 'document' |
                                                               'empty' | 'inline' | 'namespaces' | '}' :)
    return
      if ($state[$p:l1] = 95) then                          (: '}' :)
        $state
      else
        let $state :=
          if ($state[$p:l1] = 51) then                      (: 'namespaces' :)
            let $state := p:parse-namespaces($input, $state)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:parse-binding($input, $state)
            return $state
        return p:parse-withParamBody-1($input, $state)
};

(:~
 : Parse withParamBody.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-withParamBody($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(94, $input, $state)                 (: '{' :)
  let $state := p:parse-withParamBody-1($input, $state)
  let $state := p:shift(95, $input, $state)                 (: '}' :)
  return p:reduce($state, "withParamBody", $count)
};

(:~
 : Parse withParam.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-withParam($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(83, $input, $state)                 (: 'with-param' :)
  let $state := p:lookahead1W(9, $input, $state)            (: S | QName :)
  let $state := p:shift(8, $input, $state)                  (: QName :)
  let $state := p:lookahead1W(11, $input, $state)           (: S | '=' :)
  let $state := p:shift(13, $input, $state)                 (: '=' :)
  let $state := p:lookahead1W(7, $input, $state)            (: S | quotedstr :)
  let $state := p:shift(5, $input, $state)                  (: quotedstr :)
  let $state := p:lookahead1W(32, $input, $state)           (: S | 'input' | 'log' | 'with' | 'with-option' |
                                                               'with-param' | '{' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 81) then                       (: 'with' :)
      let $state := p:parse-withExtra($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(31, $input, $state)           (: S | 'input' | 'log' | 'with-option' | 'with-param' |
                                                               '{' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 94) then                       (: '{' :)
      let $state := p:parse-withParamBody($input, $state)
      return $state
    else
      $state
  return p:reduce($state, "withParam", $count)
};

(:~
 : Parse the 1st loop of production withOptionBody (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-withOptionBody-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(34, $input, $state)         (: S | comment | pi | quotedstr | 'data' | 'document' |
                                                               'empty' | 'inline' | 'namespaces' | '}' :)
    return
      if ($state[$p:l1] = 95) then                          (: '}' :)
        $state
      else
        let $state :=
          if ($state[$p:l1] = 51) then                      (: 'namespaces' :)
            let $state := p:parse-namespaces($input, $state)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:parse-binding($input, $state)
            return $state
        return p:parse-withOptionBody-1($input, $state)
};

(:~
 : Parse withOptionBody.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-withOptionBody($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(94, $input, $state)                 (: '{' :)
  let $state := p:parse-withOptionBody-1($input, $state)
  let $state := p:shift(95, $input, $state)                 (: '}' :)
  return p:reduce($state, "withOptionBody", $count)
};

(:~
 : Parse withOption.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-withOption($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(82, $input, $state)                 (: 'with-option' :)
  let $state := p:lookahead1W(9, $input, $state)            (: S | QName :)
  let $state := p:shift(8, $input, $state)                  (: QName :)
  let $state := p:lookahead1W(11, $input, $state)           (: S | '=' :)
  let $state := p:shift(13, $input, $state)                 (: '=' :)
  let $state := p:lookahead1W(7, $input, $state)            (: S | quotedstr :)
  let $state := p:shift(5, $input, $state)                  (: quotedstr :)
  let $state := p:lookahead1W(32, $input, $state)           (: S | 'input' | 'log' | 'with' | 'with-option' |
                                                               'with-param' | '{' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 81) then                       (: 'with' :)
      let $state := p:parse-withExtra($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(31, $input, $state)           (: S | 'input' | 'log' | 'with-option' | 'with-param' |
                                                               '{' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 94) then                       (: '{' :)
      let $state := p:parse-withOptionBody($input, $state)
      return $state
    else
      $state
  return p:reduce($state, "withOption", $count)
};

(:~
 : Parse the 1st loop of production atomicStepBody (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-atomicStepBody-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(29, $input, $state)         (: S | 'input' | 'log' | 'with-option' | 'with-param' | '}' :)
    return
      if ($state[$p:l1] = 95) then                          (: '}' :)
        $state
      else
        let $state :=
          if ($state[$p:l1] = 40) then                      (: 'input' :)
            let $state := p:parse-input($input, $state)
            return $state
          else if ($state[$p:l1] = 82) then                 (: 'with-option' :)
            let $state := p:parse-withOption($input, $state)
            return $state
          else if ($state[$p:l1] = 83) then                 (: 'with-param' :)
            let $state := p:parse-withParam($input, $state)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:parse-log($input, $state)
            return $state
        return p:parse-atomicStepBody-1($input, $state)
};

(:~
 : Parse atomicStepBody.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-atomicStepBody($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(94, $input, $state)                 (: '{' :)
  let $state := p:parse-atomicStepBody-1($input, $state)
  let $state := p:shift(95, $input, $state)                 (: '}' :)
  return p:reduce($state, "atomicStepBody", $count)
};

(:~
 : Parse atomicStep.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-atomicStep($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 7) then                             (: CName :)
      let $state := p:shift(7, $input, $state)              (: CName :)
      let $state := p:lookahead1W(51, $input, $state)       (: S | comment | pi | CName | 'add-attribute' |
                                                               'add-xml-base' | 'choose' | 'compare' | 'count' |
                                                               'delete' | 'directory-list' | 'documentation' | 'error' |
                                                               'escape-markup' | 'exec' | 'filter' | 'for-each' |
                                                               'group' | 'hash' | 'http-request' | 'identity' |
                                                               'insert' | 'label-elements' | 'load' |
                                                               'make-absolute-uris' | 'named' | 'namespace-rename' |
                                                               'otherwise' | 'pack' | 'parameters' | 'pipeinfo' |
                                                               'rename' | 'replace' | 'set-attributes' | 'sink' |
                                                               'split-sequence' | 'store' | 'string-replace' | 'try' |
                                                               'unescape-markup' | 'unwrap' | 'uuid' |
                                                               'validate-with-relax-ng' | 'validate-with-schematron' |
                                                               'validate-with-xml-schema' | 'variable' | 'viewport' |
                                                               'when' | 'with' | 'wrap' | 'wrap-sequence' |
                                                               'www-form-urldecode' | 'www-form-urlencode' |
                                                               'xinclude' | 'xquery' | 'xsl-formatter' | 'xslt' | '{' |
                                                               '}' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 48) then                   (: 'named' :)
          let $state := p:parse-named($input, $state)
          return $state
        else
          $state
      let $state := p:lookahead1W(50, $input, $state)       (: S | comment | pi | CName | 'add-attribute' |
                                                               'add-xml-base' | 'choose' | 'compare' | 'count' |
                                                               'delete' | 'directory-list' | 'documentation' | 'error' |
                                                               'escape-markup' | 'exec' | 'filter' | 'for-each' |
                                                               'group' | 'hash' | 'http-request' | 'identity' |
                                                               'insert' | 'label-elements' | 'load' |
                                                               'make-absolute-uris' | 'namespace-rename' | 'otherwise' |
                                                               'pack' | 'parameters' | 'pipeinfo' | 'rename' |
                                                               'replace' | 'set-attributes' | 'sink' |
                                                               'split-sequence' | 'store' | 'string-replace' | 'try' |
                                                               'unescape-markup' | 'unwrap' | 'uuid' |
                                                               'validate-with-relax-ng' | 'validate-with-schematron' |
                                                               'validate-with-xml-schema' | 'variable' | 'viewport' |
                                                               'when' | 'with' | 'wrap' | 'wrap-sequence' |
                                                               'www-form-urldecode' | 'www-form-urlencode' |
                                                               'xinclude' | 'xquery' | 'xsl-formatter' | 'xslt' | '{' |
                                                               '}' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 81) then                   (: 'with' :)
          let $state := p:parse-withExtra($input, $state)
          return $state
        else
          $state
      let $state := p:lookahead1W(47, $input, $state)       (: S | comment | pi | CName | 'add-attribute' |
                                                               'add-xml-base' | 'choose' | 'compare' | 'count' |
                                                               'delete' | 'directory-list' | 'documentation' | 'error' |
                                                               'escape-markup' | 'exec' | 'filter' | 'for-each' |
                                                               'group' | 'hash' | 'http-request' | 'identity' |
                                                               'insert' | 'label-elements' | 'load' |
                                                               'make-absolute-uris' | 'namespace-rename' | 'otherwise' |
                                                               'pack' | 'parameters' | 'pipeinfo' | 'rename' |
                                                               'replace' | 'set-attributes' | 'sink' |
                                                               'split-sequence' | 'store' | 'string-replace' | 'try' |
                                                               'unescape-markup' | 'unwrap' | 'uuid' |
                                                               'validate-with-relax-ng' | 'validate-with-schematron' |
                                                               'validate-with-xml-schema' | 'variable' | 'viewport' |
                                                               'when' | 'wrap' | 'wrap-sequence' |
                                                               'www-form-urldecode' | 'www-form-urlencode' |
                                                               'xinclude' | 'xquery' | 'xsl-formatter' | 'xslt' | '{' |
                                                               '}' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 94) then                   (: '{' :)
          let $state := p:parse-atomicStepBody($input, $state)
          return $state
        else
          $state
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state :=
        if ($state[$p:l1] = 16) then                        (: 'add-xml-base' :)
          let $state := p:shift(16, $input, $state)         (: 'add-xml-base' :)
          return $state
        else if ($state[$p:l1] = 15) then                   (: 'add-attribute' :)
          let $state := p:shift(15, $input, $state)         (: 'add-attribute' :)
          return $state
        else if ($state[$p:l1] = 19) then                   (: 'compare' :)
          let $state := p:shift(19, $input, $state)         (: 'compare' :)
          return $state
        else if ($state[$p:l1] = 20) then                   (: 'count' :)
          let $state := p:shift(20, $input, $state)         (: 'count' :)
          return $state
        else if ($state[$p:l1] = 24) then                   (: 'delete' :)
          let $state := p:shift(24, $input, $state)         (: 'delete' :)
          return $state
        else if ($state[$p:l1] = 25) then                   (: 'directory-list' :)
          let $state := p:shift(25, $input, $state)         (: 'directory-list' :)
          return $state
        else if ($state[$p:l1] = 29) then                   (: 'error' :)
          let $state := p:shift(29, $input, $state)         (: 'error' :)
          return $state
        else if ($state[$p:l1] = 30) then                   (: 'escape-markup' :)
          let $state := p:shift(30, $input, $state)         (: 'escape-markup' :)
          return $state
        else if ($state[$p:l1] = 31) then                   (: 'exec' :)
          let $state := p:shift(31, $input, $state)         (: 'exec' :)
          return $state
        else if ($state[$p:l1] = 32) then                   (: 'filter' :)
          let $state := p:shift(32, $input, $state)         (: 'filter' :)
          return $state
        else if ($state[$p:l1] = 35) then                   (: 'hash' :)
          let $state := p:shift(35, $input, $state)         (: 'hash' :)
          return $state
        else if ($state[$p:l1] = 36) then                   (: 'http-request' :)
          let $state := p:shift(36, $input, $state)         (: 'http-request' :)
          return $state
        else if ($state[$p:l1] = 37) then                   (: 'identity' :)
          let $state := p:shift(37, $input, $state)         (: 'identity' :)
          return $state
        else if ($state[$p:l1] = 41) then                   (: 'insert' :)
          let $state := p:shift(41, $input, $state)         (: 'insert' :)
          return $state
        else if ($state[$p:l1] = 43) then                   (: 'label-elements' :)
          let $state := p:shift(43, $input, $state)         (: 'label-elements' :)
          return $state
        else if ($state[$p:l1] = 45) then                   (: 'load' :)
          let $state := p:shift(45, $input, $state)         (: 'load' :)
          return $state
        else if ($state[$p:l1] = 47) then                   (: 'make-absolute-uris' :)
          let $state := p:shift(47, $input, $state)         (: 'make-absolute-uris' :)
          return $state
        else if ($state[$p:l1] = 50) then                   (: 'namespace-rename' :)
          let $state := p:shift(50, $input, $state)         (: 'namespace-rename' :)
          return $state
        else if ($state[$p:l1] = 56) then                   (: 'pack' :)
          let $state := p:shift(56, $input, $state)         (: 'pack' :)
          return $state
        else if ($state[$p:l1] = 57) then                   (: 'parameters' :)
          let $state := p:shift(57, $input, $state)         (: 'parameters' :)
          return $state
        else if ($state[$p:l1] = 60) then                   (: 'rename' :)
          let $state := p:shift(60, $input, $state)         (: 'rename' :)
          return $state
        else if ($state[$p:l1] = 61) then                   (: 'replace' :)
          let $state := p:shift(61, $input, $state)         (: 'replace' :)
          return $state
        else if ($state[$p:l1] = 64) then                   (: 'set-attributes' :)
          let $state := p:shift(64, $input, $state)         (: 'set-attributes' :)
          return $state
        else if ($state[$p:l1] = 65) then                   (: 'sink' :)
          let $state := p:shift(65, $input, $state)         (: 'sink' :)
          return $state
        else if ($state[$p:l1] = 66) then                   (: 'split-sequence' :)
          let $state := p:shift(66, $input, $state)         (: 'split-sequence' :)
          return $state
        else if ($state[$p:l1] = 67) then                   (: 'store' :)
          let $state := p:shift(67, $input, $state)         (: 'store' :)
          return $state
        else if ($state[$p:l1] = 68) then                   (: 'string-replace' :)
          let $state := p:shift(68, $input, $state)         (: 'string-replace' :)
          return $state
        else if ($state[$p:l1] = 71) then                   (: 'unescape-markup' :)
          let $state := p:shift(71, $input, $state)         (: 'unescape-markup' :)
          return $state
        else if ($state[$p:l1] = 72) then                   (: 'unwrap' :)
          let $state := p:shift(72, $input, $state)         (: 'unwrap' :)
          return $state
        else if ($state[$p:l1] = 73) then                   (: 'uuid' :)
          let $state := p:shift(73, $input, $state)         (: 'uuid' :)
          return $state
        else if ($state[$p:l1] = 74) then                   (: 'validate-with-relax-ng' :)
          let $state := p:shift(74, $input, $state)         (: 'validate-with-relax-ng' :)
          return $state
        else if ($state[$p:l1] = 75) then                   (: 'validate-with-schematron' :)
          let $state := p:shift(75, $input, $state)         (: 'validate-with-schematron' :)
          return $state
        else if ($state[$p:l1] = 76) then                   (: 'validate-with-xml-schema' :)
          let $state := p:shift(76, $input, $state)         (: 'validate-with-xml-schema' :)
          return $state
        else if ($state[$p:l1] = 84) then                   (: 'wrap' :)
          let $state := p:shift(84, $input, $state)         (: 'wrap' :)
          return $state
        else if ($state[$p:l1] = 85) then                   (: 'wrap-sequence' :)
          let $state := p:shift(85, $input, $state)         (: 'wrap-sequence' :)
          return $state
        else if ($state[$p:l1] = 86) then                   (: 'www-form-urldecode' :)
          let $state := p:shift(86, $input, $state)         (: 'www-form-urldecode' :)
          return $state
        else if ($state[$p:l1] = 87) then                   (: 'www-form-urlencode' :)
          let $state := p:shift(87, $input, $state)         (: 'www-form-urlencode' :)
          return $state
        else if ($state[$p:l1] = 88) then                   (: 'xinclude' :)
          let $state := p:shift(88, $input, $state)         (: 'xinclude' :)
          return $state
        else if ($state[$p:l1] = 91) then                   (: 'xquery' :)
          let $state := p:shift(91, $input, $state)         (: 'xquery' :)
          return $state
        else if ($state[$p:l1] = 93) then                   (: 'xslt' :)
          let $state := p:shift(93, $input, $state)         (: 'xslt' :)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:shift(92, $input, $state)         (: 'xsl-formatter' :)
          return $state
      let $state := p:lookahead1W(51, $input, $state)       (: S | comment | pi | CName | 'add-attribute' |
                                                               'add-xml-base' | 'choose' | 'compare' | 'count' |
                                                               'delete' | 'directory-list' | 'documentation' | 'error' |
                                                               'escape-markup' | 'exec' | 'filter' | 'for-each' |
                                                               'group' | 'hash' | 'http-request' | 'identity' |
                                                               'insert' | 'label-elements' | 'load' |
                                                               'make-absolute-uris' | 'named' | 'namespace-rename' |
                                                               'otherwise' | 'pack' | 'parameters' | 'pipeinfo' |
                                                               'rename' | 'replace' | 'set-attributes' | 'sink' |
                                                               'split-sequence' | 'store' | 'string-replace' | 'try' |
                                                               'unescape-markup' | 'unwrap' | 'uuid' |
                                                               'validate-with-relax-ng' | 'validate-with-schematron' |
                                                               'validate-with-xml-schema' | 'variable' | 'viewport' |
                                                               'when' | 'with' | 'wrap' | 'wrap-sequence' |
                                                               'www-form-urldecode' | 'www-form-urlencode' |
                                                               'xinclude' | 'xquery' | 'xsl-formatter' | 'xslt' | '{' |
                                                               '}' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 48) then                   (: 'named' :)
          let $state := p:parse-named($input, $state)
          return $state
        else
          $state
      let $state := p:lookahead1W(50, $input, $state)       (: S | comment | pi | CName | 'add-attribute' |
                                                               'add-xml-base' | 'choose' | 'compare' | 'count' |
                                                               'delete' | 'directory-list' | 'documentation' | 'error' |
                                                               'escape-markup' | 'exec' | 'filter' | 'for-each' |
                                                               'group' | 'hash' | 'http-request' | 'identity' |
                                                               'insert' | 'label-elements' | 'load' |
                                                               'make-absolute-uris' | 'namespace-rename' | 'otherwise' |
                                                               'pack' | 'parameters' | 'pipeinfo' | 'rename' |
                                                               'replace' | 'set-attributes' | 'sink' |
                                                               'split-sequence' | 'store' | 'string-replace' | 'try' |
                                                               'unescape-markup' | 'unwrap' | 'uuid' |
                                                               'validate-with-relax-ng' | 'validate-with-schematron' |
                                                               'validate-with-xml-schema' | 'variable' | 'viewport' |
                                                               'when' | 'with' | 'wrap' | 'wrap-sequence' |
                                                               'www-form-urldecode' | 'www-form-urlencode' |
                                                               'xinclude' | 'xquery' | 'xsl-formatter' | 'xslt' | '{' |
                                                               '}' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 81) then                   (: 'with' :)
          let $state := p:parse-withExtra($input, $state)
          return $state
        else
          $state
      let $state := p:lookahead1W(47, $input, $state)       (: S | comment | pi | CName | 'add-attribute' |
                                                               'add-xml-base' | 'choose' | 'compare' | 'count' |
                                                               'delete' | 'directory-list' | 'documentation' | 'error' |
                                                               'escape-markup' | 'exec' | 'filter' | 'for-each' |
                                                               'group' | 'hash' | 'http-request' | 'identity' |
                                                               'insert' | 'label-elements' | 'load' |
                                                               'make-absolute-uris' | 'namespace-rename' | 'otherwise' |
                                                               'pack' | 'parameters' | 'pipeinfo' | 'rename' |
                                                               'replace' | 'set-attributes' | 'sink' |
                                                               'split-sequence' | 'store' | 'string-replace' | 'try' |
                                                               'unescape-markup' | 'unwrap' | 'uuid' |
                                                               'validate-with-relax-ng' | 'validate-with-schematron' |
                                                               'validate-with-xml-schema' | 'variable' | 'viewport' |
                                                               'when' | 'wrap' | 'wrap-sequence' |
                                                               'www-form-urldecode' | 'www-form-urlencode' |
                                                               'xinclude' | 'xquery' | 'xsl-formatter' | 'xslt' | '{' |
                                                               '}' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 94) then                   (: '{' :)
          let $state := p:parse-atomicStepBody($input, $state)
          return $state
        else
          $state
      return $state
  return p:reduce($state, "atomicStep", $count)
};

(:~
 : Parse the 1st loop of production catchBody (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-catchBody-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(38, $input, $state)         (: S | comment | pi | CName | 'add-attribute' |
                                                               'add-xml-base' | 'choose' | 'compare' | 'count' |
                                                               'delete' | 'directory-list' | 'documentation' | 'error' |
                                                               'escape-markup' | 'exec' | 'filter' | 'for-each' |
                                                               'group' | 'hash' | 'http-request' | 'identity' |
                                                               'insert' | 'label-elements' | 'load' | 'log' |
                                                               'make-absolute-uris' | 'namespace-rename' | 'output' |
                                                               'pack' | 'parameters' | 'pipeinfo' | 'rename' |
                                                               'replace' | 'set-attributes' | 'sink' |
                                                               'split-sequence' | 'store' | 'string-replace' | 'try' |
                                                               'unescape-markup' | 'unwrap' | 'uuid' |
                                                               'validate-with-relax-ng' | 'validate-with-schematron' |
                                                               'validate-with-xml-schema' | 'variable' | 'viewport' |
                                                               'wrap' | 'wrap-sequence' | 'www-form-urldecode' |
                                                               'www-form-urlencode' | 'xinclude' | 'xquery' |
                                                               'xsl-formatter' | 'xslt' :)
    return
      if ($state[$p:l1] != 46                               (: 'log' :)
      and $state[$p:l1] != 55) then                         (: 'output' :)
        $state
      else
        let $state :=
          if ($state[$p:l1] = 55) then                      (: 'output' :)
            let $state := p:parse-output($input, $state)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:parse-log($input, $state)
            return $state
        return p:parse-catchBody-1($input, $state)
};

(:~
 : Parse catchBody.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-catchBody($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(4, $input, $state)             (: '{' :)
  let $state := p:shift(94, $input, $state)                 (: '{' :)
  let $state := p:parse-catchBody-1($input, $state)
  let $state := p:parse-subpipeline($input, $state)
  let $state := p:lookahead1W(17, $input, $state)           (: S | '}' :)
  let $state := p:shift(95, $input, $state)                 (: '}' :)
  return p:reduce($state, "catchBody", $count)
};

(:~
 : Parse catchStep.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-catchStep($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(2, $input, $state)             (: 'catch' :)
  let $state := p:shift(17, $input, $state)                 (: 'catch' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S | 'named' | 'with' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 48) then                       (: 'named' :)
      let $state := p:parse-named($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(23, $input, $state)           (: S | 'with' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 81) then                       (: 'with' :)
      let $state := p:parse-withExtra($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(5, $input, $state)            (: EPSILON | S :)
  let $state := p:parse-catchBody($input, $state)
  return p:reduce($state, "catchStep", $count)
};

(:~
 : Parse the 1st loop of production groupBody (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-groupBody-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(38, $input, $state)         (: S | comment | pi | CName | 'add-attribute' |
                                                               'add-xml-base' | 'choose' | 'compare' | 'count' |
                                                               'delete' | 'directory-list' | 'documentation' | 'error' |
                                                               'escape-markup' | 'exec' | 'filter' | 'for-each' |
                                                               'group' | 'hash' | 'http-request' | 'identity' |
                                                               'insert' | 'label-elements' | 'load' | 'log' |
                                                               'make-absolute-uris' | 'namespace-rename' | 'output' |
                                                               'pack' | 'parameters' | 'pipeinfo' | 'rename' |
                                                               'replace' | 'set-attributes' | 'sink' |
                                                               'split-sequence' | 'store' | 'string-replace' | 'try' |
                                                               'unescape-markup' | 'unwrap' | 'uuid' |
                                                               'validate-with-relax-ng' | 'validate-with-schematron' |
                                                               'validate-with-xml-schema' | 'variable' | 'viewport' |
                                                               'wrap' | 'wrap-sequence' | 'www-form-urldecode' |
                                                               'www-form-urlencode' | 'xinclude' | 'xquery' |
                                                               'xsl-formatter' | 'xslt' :)
    return
      if ($state[$p:l1] != 46                               (: 'log' :)
      and $state[$p:l1] != 55) then                         (: 'output' :)
        $state
      else
        let $state :=
          if ($state[$p:l1] = 55) then                      (: 'output' :)
            let $state := p:parse-output($input, $state)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:parse-log($input, $state)
            return $state
        return p:parse-groupBody-1($input, $state)
};

(:~
 : Parse groupBody.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-groupBody($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(4, $input, $state)             (: '{' :)
  let $state := p:shift(94, $input, $state)                 (: '{' :)
  let $state := p:parse-groupBody-1($input, $state)
  let $state := p:parse-subpipeline($input, $state)
  let $state := p:lookahead1W(17, $input, $state)           (: S | '}' :)
  let $state := p:shift(95, $input, $state)                 (: '}' :)
  return p:reduce($state, "groupBody", $count)
};

(:~
 : Parse groupStep.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-groupStep($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(34, $input, $state)                 (: 'group' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S | 'named' | 'with' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 48) then                       (: 'named' :)
      let $state := p:parse-named($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(23, $input, $state)           (: S | 'with' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 81) then                       (: 'with' :)
      let $state := p:parse-withExtra($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(5, $input, $state)            (: EPSILON | S :)
  let $state := p:parse-groupBody($input, $state)
  return p:reduce($state, "groupStep", $count)
};

(:~
 : Parse the 1st loop of production tryBody (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-tryBody-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(22, $input, $state)         (: S | 'group' | 'variable' :)
    return
      if ($state[$p:l1] != 77) then                         (: 'variable' :)
        $state
      else
        let $state := p:parse-variable($input, $state)
        return p:parse-tryBody-1($input, $state)
};

(:~
 : Parse tryBody.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-tryBody($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(4, $input, $state)             (: '{' :)
  let $state := p:shift(94, $input, $state)                 (: '{' :)
  let $state := p:parse-tryBody-1($input, $state)
  let $state := p:parse-groupStep($input, $state)
  let $state := p:lookahead1W(5, $input, $state)            (: EPSILON | S :)
  let $state := p:parse-catchStep($input, $state)
  let $state := p:lookahead1W(17, $input, $state)           (: S | '}' :)
  let $state := p:shift(95, $input, $state)                 (: '}' :)
  return p:reduce($state, "tryBody", $count)
};

(:~
 : Parse tryStep.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-tryStep($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(70, $input, $state)                 (: 'try' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S | 'named' | 'with' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 48) then                       (: 'named' :)
      let $state := p:parse-named($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(23, $input, $state)           (: S | 'with' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 81) then                       (: 'with' :)
      let $state := p:parse-withExtra($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(5, $input, $state)            (: EPSILON | S :)
  let $state := p:parse-tryBody($input, $state)
  return p:reduce($state, "tryStep", $count)
};

(:~
 : Parse the 1st loop of production otherwiseBody (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-otherwiseBody-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(38, $input, $state)         (: S | comment | pi | CName | 'add-attribute' |
                                                               'add-xml-base' | 'choose' | 'compare' | 'count' |
                                                               'delete' | 'directory-list' | 'documentation' | 'error' |
                                                               'escape-markup' | 'exec' | 'filter' | 'for-each' |
                                                               'group' | 'hash' | 'http-request' | 'identity' |
                                                               'insert' | 'label-elements' | 'load' | 'log' |
                                                               'make-absolute-uris' | 'namespace-rename' | 'output' |
                                                               'pack' | 'parameters' | 'pipeinfo' | 'rename' |
                                                               'replace' | 'set-attributes' | 'sink' |
                                                               'split-sequence' | 'store' | 'string-replace' | 'try' |
                                                               'unescape-markup' | 'unwrap' | 'uuid' |
                                                               'validate-with-relax-ng' | 'validate-with-schematron' |
                                                               'validate-with-xml-schema' | 'variable' | 'viewport' |
                                                               'wrap' | 'wrap-sequence' | 'www-form-urldecode' |
                                                               'www-form-urlencode' | 'xinclude' | 'xquery' |
                                                               'xsl-formatter' | 'xslt' :)
    return
      if ($state[$p:l1] != 46                               (: 'log' :)
      and $state[$p:l1] != 55) then                         (: 'output' :)
        $state
      else
        let $state :=
          if ($state[$p:l1] = 55) then                      (: 'output' :)
            let $state := p:parse-output($input, $state)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:parse-log($input, $state)
            return $state
        return p:parse-otherwiseBody-1($input, $state)
};

(:~
 : Parse otherwiseBody.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-otherwiseBody($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-otherwiseBody-1($input, $state)
  let $state := p:parse-subpipeline($input, $state)
  return p:reduce($state, "otherwiseBody", $count)
};

(:~
 : Parse otherwiseStep.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-otherwiseStep($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(54, $input, $state)                 (: 'otherwise' :)
  let $state := p:lookahead1W(41, $input, $state)           (: S | comment | pi | CName | 'add-attribute' |
                                                               'add-xml-base' | 'choose' | 'compare' | 'count' |
                                                               'delete' | 'directory-list' | 'documentation' | 'error' |
                                                               'escape-markup' | 'exec' | 'filter' | 'for-each' |
                                                               'group' | 'hash' | 'http-request' | 'identity' |
                                                               'insert' | 'label-elements' | 'load' | 'log' |
                                                               'make-absolute-uris' | 'namespace-rename' | 'output' |
                                                               'pack' | 'parameters' | 'pipeinfo' | 'rename' |
                                                               'replace' | 'set-attributes' | 'sink' |
                                                               'split-sequence' | 'store' | 'string-replace' | 'try' |
                                                               'unescape-markup' | 'unwrap' | 'uuid' |
                                                               'validate-with-relax-ng' | 'validate-with-schematron' |
                                                               'validate-with-xml-schema' | 'variable' | 'viewport' |
                                                               'with' | 'wrap' | 'wrap-sequence' |
                                                               'www-form-urldecode' | 'www-form-urlencode' |
                                                               'xinclude' | 'xquery' | 'xsl-formatter' | 'xslt' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 81) then                       (: 'with' :)
      let $state := p:parse-withExtra($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(5, $input, $state)            (: EPSILON | S :)
  let $state := p:parse-otherwiseBody($input, $state)
  return p:reduce($state, "otherwiseStep", $count)
};

(:~
 : Parse the 1st loop of production whenBody (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-whenBody-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(42, $input, $state)         (: S | comment | pi | CName | 'add-attribute' |
                                                               'add-xml-base' | 'choose' | 'compare' | 'count' |
                                                               'delete' | 'directory-list' | 'documentation' | 'error' |
                                                               'escape-markup' | 'exec' | 'filter' | 'for-each' |
                                                               'group' | 'hash' | 'http-request' | 'identity' |
                                                               'insert' | 'label-elements' | 'load' | 'log' |
                                                               'make-absolute-uris' | 'namespace-rename' | 'output' |
                                                               'pack' | 'parameters' | 'pipeinfo' | 'rename' |
                                                               'replace' | 'set-attributes' | 'sink' |
                                                               'split-sequence' | 'store' | 'string-replace' | 'try' |
                                                               'unescape-markup' | 'unwrap' | 'uuid' |
                                                               'validate-with-relax-ng' | 'validate-with-schematron' |
                                                               'validate-with-xml-schema' | 'variable' | 'viewport' |
                                                               'wrap' | 'wrap-sequence' | 'www-form-urldecode' |
                                                               'www-form-urlencode' | 'xinclude' | 'xpath-context' |
                                                               'xquery' | 'xsl-formatter' | 'xslt' :)
    return
      if ($state[$p:l1] != 46                               (: 'log' :)
      and $state[$p:l1] != 55                               (: 'output' :)
      and $state[$p:l1] != 89) then                         (: 'xpath-context' :)
        $state
      else
        let $state :=
          if ($state[$p:l1] = 89) then                      (: 'xpath-context' :)
            let $state := p:parse-xpathContext($input, $state)
            return $state
          else if ($state[$p:l1] = 55) then                 (: 'output' :)
            let $state := p:parse-output($input, $state)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:parse-log($input, $state)
            return $state
        return p:parse-whenBody-1($input, $state)
};

(:~
 : Parse whenBody.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-whenBody($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-whenBody-1($input, $state)
  let $state := p:parse-subpipeline($input, $state)
  return p:reduce($state, "whenBody", $count)
};

(:~
 : Parse whenStep.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-whenStep($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(80, $input, $state)                 (: 'when' :)
  let $state := p:lookahead1W(7, $input, $state)            (: S | quotedstr :)
  let $state := p:shift(5, $input, $state)                  (: quotedstr :)
  let $state := p:lookahead1W(46, $input, $state)           (: S | comment | pi | CName | 'add-attribute' |
                                                               'add-xml-base' | 'choose' | 'compare' | 'count' |
                                                               'delete' | 'directory-list' | 'documentation' | 'error' |
                                                               'escape-markup' | 'exec' | 'filter' | 'for-each' |
                                                               'group' | 'hash' | 'http-request' | 'identity' |
                                                               'insert' | 'label-elements' | 'load' | 'log' |
                                                               'make-absolute-uris' | 'namespace-rename' | 'output' |
                                                               'pack' | 'parameters' | 'pipeinfo' | 'rename' |
                                                               'replace' | 'set-attributes' | 'sink' |
                                                               'split-sequence' | 'store' | 'string-replace' | 'try' |
                                                               'unescape-markup' | 'unwrap' | 'uuid' |
                                                               'validate-with-relax-ng' | 'validate-with-schematron' |
                                                               'validate-with-xml-schema' | 'variable' | 'viewport' |
                                                               'with' | 'wrap' | 'wrap-sequence' |
                                                               'www-form-urldecode' | 'www-form-urlencode' |
                                                               'xinclude' | 'xpath-context' | 'xquery' |
                                                               'xsl-formatter' | 'xslt' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 81) then                       (: 'with' :)
      let $state := p:parse-withExtra($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(5, $input, $state)            (: EPSILON | S :)
  let $state := p:parse-whenBody($input, $state)
  return p:reduce($state, "whenStep", $count)
};

(:~
 : Parse the 1st loop of production xpathContext (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-xpathContext-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(33, $input, $state)         (: S | comment | pi | quotedstr | 'data' | 'document' |
                                                               'empty' | 'inline' | '}' :)
    return
      if ($state[$p:l1] = 95) then                          (: '}' :)
        $state
      else
        let $state := p:parse-binding($input, $state)
        return p:parse-xpathContext-1($input, $state)
};

(:~
 : Parse xpathContext.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-xpathContext($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(89, $input, $state)                 (: 'xpath-context' :)
  let $state := p:lookahead1W(53, $input, $state)           (: S | comment | pi | CName | 'add-attribute' |
                                                               'add-xml-base' | 'choose' | 'compare' | 'count' |
                                                               'delete' | 'directory-list' | 'documentation' | 'error' |
                                                               'escape-markup' | 'exec' | 'filter' | 'for-each' |
                                                               'group' | 'hash' | 'http-request' | 'identity' |
                                                               'insert' | 'label-elements' | 'load' | 'log' |
                                                               'make-absolute-uris' | 'namespace-rename' | 'otherwise' |
                                                               'output' | 'pack' | 'parameters' | 'pipeinfo' |
                                                               'rename' | 'replace' | 'set-attributes' | 'sink' |
                                                               'split-sequence' | 'store' | 'string-replace' | 'try' |
                                                               'unescape-markup' | 'unwrap' | 'uuid' |
                                                               'validate-with-relax-ng' | 'validate-with-schematron' |
                                                               'validate-with-xml-schema' | 'variable' | 'viewport' |
                                                               'when' | 'with' | 'wrap' | 'wrap-sequence' |
                                                               'www-form-urldecode' | 'www-form-urlencode' |
                                                               'xinclude' | 'xpath-context' | 'xquery' |
                                                               'xsl-formatter' | 'xslt' | '{' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 81) then                       (: 'with' :)
      let $state := p:parse-withExtra($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(52, $input, $state)           (: S | comment | pi | CName | 'add-attribute' |
                                                               'add-xml-base' | 'choose' | 'compare' | 'count' |
                                                               'delete' | 'directory-list' | 'documentation' | 'error' |
                                                               'escape-markup' | 'exec' | 'filter' | 'for-each' |
                                                               'group' | 'hash' | 'http-request' | 'identity' |
                                                               'insert' | 'label-elements' | 'load' | 'log' |
                                                               'make-absolute-uris' | 'namespace-rename' | 'otherwise' |
                                                               'output' | 'pack' | 'parameters' | 'pipeinfo' |
                                                               'rename' | 'replace' | 'set-attributes' | 'sink' |
                                                               'split-sequence' | 'store' | 'string-replace' | 'try' |
                                                               'unescape-markup' | 'unwrap' | 'uuid' |
                                                               'validate-with-relax-ng' | 'validate-with-schematron' |
                                                               'validate-with-xml-schema' | 'variable' | 'viewport' |
                                                               'when' | 'wrap' | 'wrap-sequence' |
                                                               'www-form-urldecode' | 'www-form-urlencode' |
                                                               'xinclude' | 'xpath-context' | 'xquery' |
                                                               'xsl-formatter' | 'xslt' | '{' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 94) then                       (: '{' :)
      let $state := p:shift(94, $input, $state)             (: '{' :)
      let $state := p:parse-xpathContext-1($input, $state)
      let $state := p:shift(95, $input, $state)             (: '}' :)
      return $state
    else
      $state
  return p:reduce($state, "xpathContext", $count)
};

(:~
 : Parse the 1st loop of production chooseBody (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-chooseBody-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(27, $input, $state)         (: S | 'otherwise' | 'variable' | 'when' | '}' :)
    return
      if ($state[$p:l1] != 77) then                         (: 'variable' :)
        $state
      else
        let $state := p:parse-variable($input, $state)
        return p:parse-chooseBody-1($input, $state)
};

(:~
 : Parse the 2nd loop of production chooseBody (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-chooseBody-2($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(25, $input, $state)         (: S | 'otherwise' | 'when' | '}' :)
    return
      if ($state[$p:l1] != 80) then                         (: 'when' :)
        $state
      else
        let $state := p:parse-whenStep($input, $state)
        return p:parse-chooseBody-2($input, $state)
};

(:~
 : Parse chooseBody.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-chooseBody($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(4, $input, $state)             (: '{' :)
  let $state := p:shift(94, $input, $state)                 (: '{' :)
  let $state := p:lookahead1W(30, $input, $state)           (: S | 'otherwise' | 'variable' | 'when' | 'xpath-context' |
                                                               '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 89) then                       (: 'xpath-context' :)
      let $state := p:parse-xpathContext($input, $state)
      return $state
    else
      $state
  let $state := p:parse-chooseBody-1($input, $state)
  let $state := p:parse-chooseBody-2($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 54) then                       (: 'otherwise' :)
      let $state := p:parse-otherwiseStep($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(17, $input, $state)           (: S | '}' :)
  let $state := p:shift(95, $input, $state)                 (: '}' :)
  return p:reduce($state, "chooseBody", $count)
};

(:~
 : Parse chooseStep.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-chooseStep($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(18, $input, $state)                 (: 'choose' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S | 'named' | 'with' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 48) then                       (: 'named' :)
      let $state := p:parse-named($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(23, $input, $state)           (: S | 'with' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 81) then                       (: 'with' :)
      let $state := p:parse-withExtra($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(5, $input, $state)            (: EPSILON | S :)
  let $state := p:parse-chooseBody($input, $state)
  return p:reduce($state, "chooseStep", $count)
};

(:~
 : Parse the 1st loop of production viewportSource (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-viewportSource-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(33, $input, $state)         (: S | comment | pi | quotedstr | 'data' | 'document' |
                                                               'empty' | 'inline' | '}' :)
    return
      if ($state[$p:l1] = 95) then                          (: '}' :)
        $state
      else
        let $state := p:parse-binding($input, $state)
        return p:parse-viewportSource-1($input, $state)
};

(:~
 : Parse viewportSource.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-viewportSource($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(79, $input, $state)                 (: 'viewport-source' :)
  let $state := p:lookahead1W(49, $input, $state)           (: S | comment | pi | CName | 'add-attribute' |
                                                               'add-xml-base' | 'choose' | 'compare' | 'count' |
                                                               'delete' | 'directory-list' | 'documentation' | 'error' |
                                                               'escape-markup' | 'exec' | 'filter' | 'for-each' |
                                                               'group' | 'hash' | 'http-request' | 'identity' |
                                                               'insert' | 'label-elements' | 'load' | 'log' |
                                                               'make-absolute-uris' | 'namespace-rename' | 'output' |
                                                               'pack' | 'parameters' | 'pipeinfo' | 'rename' |
                                                               'replace' | 'set-attributes' | 'sink' |
                                                               'split-sequence' | 'store' | 'string-replace' | 'try' |
                                                               'unescape-markup' | 'unwrap' | 'uuid' |
                                                               'validate-with-relax-ng' | 'validate-with-schematron' |
                                                               'validate-with-xml-schema' | 'variable' | 'viewport' |
                                                               'viewport-source' | 'with' | 'wrap' | 'wrap-sequence' |
                                                               'www-form-urldecode' | 'www-form-urlencode' |
                                                               'xinclude' | 'xquery' | 'xsl-formatter' | 'xslt' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 81) then                       (: 'with' :)
      let $state := p:parse-withExtra($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(45, $input, $state)           (: S | comment | pi | CName | 'add-attribute' |
                                                               'add-xml-base' | 'choose' | 'compare' | 'count' |
                                                               'delete' | 'directory-list' | 'documentation' | 'error' |
                                                               'escape-markup' | 'exec' | 'filter' | 'for-each' |
                                                               'group' | 'hash' | 'http-request' | 'identity' |
                                                               'insert' | 'label-elements' | 'load' | 'log' |
                                                               'make-absolute-uris' | 'namespace-rename' | 'output' |
                                                               'pack' | 'parameters' | 'pipeinfo' | 'rename' |
                                                               'replace' | 'set-attributes' | 'sink' |
                                                               'split-sequence' | 'store' | 'string-replace' | 'try' |
                                                               'unescape-markup' | 'unwrap' | 'uuid' |
                                                               'validate-with-relax-ng' | 'validate-with-schematron' |
                                                               'validate-with-xml-schema' | 'variable' | 'viewport' |
                                                               'viewport-source' | 'wrap' | 'wrap-sequence' |
                                                               'www-form-urldecode' | 'www-form-urlencode' |
                                                               'xinclude' | 'xquery' | 'xsl-formatter' | 'xslt' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 94) then                       (: '{' :)
      let $state := p:shift(94, $input, $state)             (: '{' :)
      let $state := p:parse-viewportSource-1($input, $state)
      let $state := p:shift(95, $input, $state)             (: '}' :)
      return $state
    else
      $state
  return p:reduce($state, "viewportSource", $count)
};

(:~
 : Parse the 1st loop of production viewportBody (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-viewportBody-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(40, $input, $state)         (: S | comment | pi | CName | 'add-attribute' |
                                                               'add-xml-base' | 'choose' | 'compare' | 'count' |
                                                               'delete' | 'directory-list' | 'documentation' | 'error' |
                                                               'escape-markup' | 'exec' | 'filter' | 'for-each' |
                                                               'group' | 'hash' | 'http-request' | 'identity' |
                                                               'insert' | 'label-elements' | 'load' | 'log' |
                                                               'make-absolute-uris' | 'namespace-rename' | 'output' |
                                                               'pack' | 'parameters' | 'pipeinfo' | 'rename' |
                                                               'replace' | 'set-attributes' | 'sink' |
                                                               'split-sequence' | 'store' | 'string-replace' | 'try' |
                                                               'unescape-markup' | 'unwrap' | 'uuid' |
                                                               'validate-with-relax-ng' | 'validate-with-schematron' |
                                                               'validate-with-xml-schema' | 'variable' | 'viewport' |
                                                               'viewport-source' | 'wrap' | 'wrap-sequence' |
                                                               'www-form-urldecode' | 'www-form-urlencode' |
                                                               'xinclude' | 'xquery' | 'xsl-formatter' | 'xslt' :)
    return
      if ($state[$p:l1] != 46                               (: 'log' :)
      and $state[$p:l1] != 55                               (: 'output' :)
      and $state[$p:l1] != 79) then                         (: 'viewport-source' :)
        $state
      else
        let $state :=
          if ($state[$p:l1] = 79) then                      (: 'viewport-source' :)
            let $state := p:parse-viewportSource($input, $state)
            return $state
          else if ($state[$p:l1] = 55) then                 (: 'output' :)
            let $state := p:parse-output($input, $state)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:parse-log($input, $state)
            return $state
        return p:parse-viewportBody-1($input, $state)
};

(:~
 : Parse viewportBody.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-viewportBody($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(4, $input, $state)             (: '{' :)
  let $state := p:shift(94, $input, $state)                 (: '{' :)
  let $state := p:parse-viewportBody-1($input, $state)
  let $state := p:parse-subpipeline($input, $state)
  let $state := p:lookahead1W(17, $input, $state)           (: S | '}' :)
  let $state := p:shift(95, $input, $state)                 (: '}' :)
  return p:reduce($state, "viewportBody", $count)
};

(:~
 : Parse viewportStep.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-viewportStep($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(78, $input, $state)                 (: 'viewport' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S | 'named' | 'with' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 48) then                       (: 'named' :)
      let $state := p:parse-named($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(23, $input, $state)           (: S | 'with' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 81) then                       (: 'with' :)
      let $state := p:parse-withExtra($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(5, $input, $state)            (: EPSILON | S :)
  let $state := p:parse-viewportBody($input, $state)
  return p:reduce($state, "viewportStep", $count)
};

(:~
 : Parse the 1st loop of production iterationSource (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-iterationSource-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(33, $input, $state)         (: S | comment | pi | quotedstr | 'data' | 'document' |
                                                               'empty' | 'inline' | '}' :)
    return
      if ($state[$p:l1] = 95) then                          (: '}' :)
        $state
      else
        let $state := p:parse-binding($input, $state)
        return p:parse-iterationSource-1($input, $state)
};

(:~
 : Parse iterationSource.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-iterationSource($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(42, $input, $state)                 (: 'iteration-source' :)
  let $state := p:lookahead1W(48, $input, $state)           (: S | comment | pi | CName | 'add-attribute' |
                                                               'add-xml-base' | 'choose' | 'compare' | 'count' |
                                                               'delete' | 'directory-list' | 'documentation' | 'error' |
                                                               'escape-markup' | 'exec' | 'filter' | 'for-each' |
                                                               'group' | 'hash' | 'http-request' | 'identity' |
                                                               'insert' | 'iteration-source' | 'label-elements' |
                                                               'load' | 'log' | 'make-absolute-uris' |
                                                               'namespace-rename' | 'output' | 'pack' | 'parameters' |
                                                               'pipeinfo' | 'rename' | 'replace' | 'set-attributes' |
                                                               'sink' | 'split-sequence' | 'store' | 'string-replace' |
                                                               'try' | 'unescape-markup' | 'unwrap' | 'uuid' |
                                                               'validate-with-relax-ng' | 'validate-with-schematron' |
                                                               'validate-with-xml-schema' | 'variable' | 'viewport' |
                                                               'with' | 'wrap' | 'wrap-sequence' |
                                                               'www-form-urldecode' | 'www-form-urlencode' |
                                                               'xinclude' | 'xquery' | 'xsl-formatter' | 'xslt' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 81) then                       (: 'with' :)
      let $state := p:parse-withExtra($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(44, $input, $state)           (: S | comment | pi | CName | 'add-attribute' |
                                                               'add-xml-base' | 'choose' | 'compare' | 'count' |
                                                               'delete' | 'directory-list' | 'documentation' | 'error' |
                                                               'escape-markup' | 'exec' | 'filter' | 'for-each' |
                                                               'group' | 'hash' | 'http-request' | 'identity' |
                                                               'insert' | 'iteration-source' | 'label-elements' |
                                                               'load' | 'log' | 'make-absolute-uris' |
                                                               'namespace-rename' | 'output' | 'pack' | 'parameters' |
                                                               'pipeinfo' | 'rename' | 'replace' | 'set-attributes' |
                                                               'sink' | 'split-sequence' | 'store' | 'string-replace' |
                                                               'try' | 'unescape-markup' | 'unwrap' | 'uuid' |
                                                               'validate-with-relax-ng' | 'validate-with-schematron' |
                                                               'validate-with-xml-schema' | 'variable' | 'viewport' |
                                                               'wrap' | 'wrap-sequence' | 'www-form-urldecode' |
                                                               'www-form-urlencode' | 'xinclude' | 'xquery' |
                                                               'xsl-formatter' | 'xslt' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 94) then                       (: '{' :)
      let $state := p:shift(94, $input, $state)             (: '{' :)
      let $state := p:parse-iterationSource-1($input, $state)
      let $state := p:shift(95, $input, $state)             (: '}' :)
      return $state
    else
      $state
  return p:reduce($state, "iterationSource", $count)
};

(:~
 : Parse the 1st loop of production forEachBody (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-forEachBody-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(39, $input, $state)         (: S | comment | pi | CName | 'add-attribute' |
                                                               'add-xml-base' | 'choose' | 'compare' | 'count' |
                                                               'delete' | 'directory-list' | 'documentation' | 'error' |
                                                               'escape-markup' | 'exec' | 'filter' | 'for-each' |
                                                               'group' | 'hash' | 'http-request' | 'identity' |
                                                               'insert' | 'iteration-source' | 'label-elements' |
                                                               'load' | 'log' | 'make-absolute-uris' |
                                                               'namespace-rename' | 'output' | 'pack' | 'parameters' |
                                                               'pipeinfo' | 'rename' | 'replace' | 'set-attributes' |
                                                               'sink' | 'split-sequence' | 'store' | 'string-replace' |
                                                               'try' | 'unescape-markup' | 'unwrap' | 'uuid' |
                                                               'validate-with-relax-ng' | 'validate-with-schematron' |
                                                               'validate-with-xml-schema' | 'variable' | 'viewport' |
                                                               'wrap' | 'wrap-sequence' | 'www-form-urldecode' |
                                                               'www-form-urlencode' | 'xinclude' | 'xquery' |
                                                               'xsl-formatter' | 'xslt' :)
    return
      if ($state[$p:l1] != 42                               (: 'iteration-source' :)
      and $state[$p:l1] != 46                               (: 'log' :)
      and $state[$p:l1] != 55) then                         (: 'output' :)
        $state
      else
        let $state :=
          if ($state[$p:l1] = 42) then                      (: 'iteration-source' :)
            let $state := p:parse-iterationSource($input, $state)
            return $state
          else if ($state[$p:l1] = 55) then                 (: 'output' :)
            let $state := p:parse-output($input, $state)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:parse-log($input, $state)
            return $state
        return p:parse-forEachBody-1($input, $state)
};

(:~
 : Parse forEachBody.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-forEachBody($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(4, $input, $state)             (: '{' :)
  let $state := p:shift(94, $input, $state)                 (: '{' :)
  let $state := p:parse-forEachBody-1($input, $state)
  let $state := p:parse-subpipeline($input, $state)
  let $state := p:lookahead1W(17, $input, $state)           (: S | '}' :)
  let $state := p:shift(95, $input, $state)                 (: '}' :)
  return p:reduce($state, "forEachBody", $count)
};

(:~
 : Parse forEachStep.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-forEachStep($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(33, $input, $state)                 (: 'for-each' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S | 'named' | 'with' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 48) then                       (: 'named' :)
      let $state := p:parse-named($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(23, $input, $state)           (: S | 'with' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 81) then                       (: 'with' :)
      let $state := p:parse-withExtra($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(5, $input, $state)            (: EPSILON | S :)
  let $state := p:parse-forEachBody($input, $state)
  return p:reduce($state, "forEachStep", $count)
};

(:~
 : Parse pipeinfo.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-pipeinfo($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(58, $input, $state)                 (: 'pipeinfo' :)
  let $state := p:lookahead1W(23, $input, $state)           (: S | 'with' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 81) then                       (: 'with' :)
      let $state := p:parse-withExtra($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(16, $input, $state)           (: S | '{' :)
  let $state := p:shift(94, $input, $state)                 (: '{' :)
  let $state := p:lookahead1W(5, $input, $state)            (: EPSILON | S :)
  let $state := p:parse-inlineXML($input, $state)
  let $state := p:lookahead1W(17, $input, $state)           (: S | '}' :)
  let $state := p:shift(95, $input, $state)                 (: '}' :)
  return p:reduce($state, "pipeinfo", $count)
};

(:~
 : Parse documentation.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-documentation($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(27, $input, $state)                 (: 'documentation' :)
  let $state := p:lookahead1W(23, $input, $state)           (: S | 'with' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 81) then                       (: 'with' :)
      let $state := p:parse-withExtra($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(16, $input, $state)           (: S | '{' :)
  let $state := p:shift(94, $input, $state)                 (: '{' :)
  let $state := p:lookahead1W(5, $input, $state)            (: EPSILON | S :)
  let $state := p:parse-inlineXML($input, $state)
  let $state := p:lookahead1W(17, $input, $state)           (: S | '}' :)
  let $state := p:shift(95, $input, $state)                 (: '}' :)
  return p:reduce($state, "documentation", $count)
};

(:~
 : Parse nsBody.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-nsBody($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(94, $input, $state)                 (: '{' :)
  let $state := p:lookahead1W(5, $input, $state)            (: EPSILON | S :)
  let $state := p:parse-namespace($input, $state)
  let $state := p:lookahead1W(17, $input, $state)           (: S | '}' :)
  let $state := p:shift(95, $input, $state)                 (: '}' :)
  return p:reduce($state, "nsBody", $count)
};

(:~
 : Parse namespaces.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-namespaces($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(51, $input, $state)                 (: 'namespaces' :)
  let $state := p:lookahead1W(37, $input, $state)           (: S | comment | pi | quotedstr | 'data' | 'document' |
                                                               'empty' | 'inline' | 'namespaces' | 'with' | '{' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 81) then                       (: 'with' :)
      let $state := p:parse-withExtra($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(36, $input, $state)           (: S | comment | pi | quotedstr | 'data' | 'document' |
                                                               'empty' | 'inline' | 'namespaces' | '{' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 94) then                       (: '{' :)
      let $state := p:parse-nsBody($input, $state)
      return $state
    else
      $state
  return p:reduce($state, "namespaces", $count)
};

(:~
 : Parse the 1st loop of production variableBody (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-variableBody-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(34, $input, $state)         (: S | comment | pi | quotedstr | 'data' | 'document' |
                                                               'empty' | 'inline' | 'namespaces' | '}' :)
    return
      if ($state[$p:l1] = 95) then                          (: '}' :)
        $state
      else
        let $state :=
          if ($state[$p:l1] = 51) then                      (: 'namespaces' :)
            let $state := p:parse-namespaces($input, $state)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:parse-binding($input, $state)
            return $state
        return p:parse-variableBody-1($input, $state)
};

(:~
 : Parse variableBody.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-variableBody($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(94, $input, $state)                 (: '{' :)
  let $state := p:parse-variableBody-1($input, $state)
  let $state := p:shift(95, $input, $state)                 (: '}' :)
  return p:reduce($state, "variableBody", $count)
};

(:~
 : Parse variable.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-variable($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(77, $input, $state)                 (: 'variable' :)
  let $state := p:lookahead1W(9, $input, $state)            (: S | QName :)
  let $state := p:shift(8, $input, $state)                  (: QName :)
  let $state := p:lookahead1W(11, $input, $state)           (: S | '=' :)
  let $state := p:shift(13, $input, $state)                 (: '=' :)
  let $state := p:lookahead1W(7, $input, $state)            (: S | quotedstr :)
  let $state := p:shift(5, $input, $state)                  (: quotedstr :)
  let $state := p:lookahead1W(47, $input, $state)           (: S | comment | pi | CName | 'add-attribute' |
                                                               'add-xml-base' | 'choose' | 'compare' | 'count' |
                                                               'delete' | 'directory-list' | 'documentation' | 'error' |
                                                               'escape-markup' | 'exec' | 'filter' | 'for-each' |
                                                               'group' | 'hash' | 'http-request' | 'identity' |
                                                               'insert' | 'label-elements' | 'load' |
                                                               'make-absolute-uris' | 'namespace-rename' | 'otherwise' |
                                                               'pack' | 'parameters' | 'pipeinfo' | 'rename' |
                                                               'replace' | 'set-attributes' | 'sink' |
                                                               'split-sequence' | 'store' | 'string-replace' | 'try' |
                                                               'unescape-markup' | 'unwrap' | 'uuid' |
                                                               'validate-with-relax-ng' | 'validate-with-schematron' |
                                                               'validate-with-xml-schema' | 'variable' | 'viewport' |
                                                               'when' | 'wrap' | 'wrap-sequence' |
                                                               'www-form-urldecode' | 'www-form-urlencode' |
                                                               'xinclude' | 'xquery' | 'xsl-formatter' | 'xslt' | '{' |
                                                               '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 94) then                       (: '{' :)
      let $state := p:parse-variableBody($input, $state)
      return $state
    else
      $state
  return p:reduce($state, "variable", $count)
};

(:~
 : Parse the 1st loop of production subpipeline (one or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-subpipeline-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state :=
      if ($state[$p:l1] = 77) then                          (: 'variable' :)
        let $state := p:parse-variable($input, $state)
        return $state
      else if ($state[$p:l1] = 27) then                     (: 'documentation' :)
        let $state := p:parse-documentation($input, $state)
        return $state
      else if ($state[$p:l1] = 58) then                     (: 'pipeinfo' :)
        let $state := p:parse-pipeinfo($input, $state)
        return $state
      else if ($state[$p:l1] = 33) then                     (: 'for-each' :)
        let $state := p:parse-forEachStep($input, $state)
        return $state
      else if ($state[$p:l1] = 78) then                     (: 'viewport' :)
        let $state := p:parse-viewportStep($input, $state)
        return $state
      else if ($state[$p:l1] = 18) then                     (: 'choose' :)
        let $state := p:parse-chooseStep($input, $state)
        return $state
      else if ($state[$p:l1] = 70) then                     (: 'try' :)
        let $state := p:parse-tryStep($input, $state)
        return $state
      else if ($state[$p:l1] = 34) then                     (: 'group' :)
        let $state := p:parse-groupStep($input, $state)
        return $state
      else if ($state[$p:l1] = 3) then                      (: comment :)
        let $state := p:shift(3, $input, $state)            (: comment :)
        return $state
      else if ($state[$p:l1] = 4) then                      (: pi :)
        let $state := p:shift(4, $input, $state)            (: pi :)
        return $state
      else if ($state[$p:error]) then
        $state
      else
        let $state := p:parse-atomicStep($input, $state)
        return $state
    let $state := p:lookahead1W(43, $input, $state)         (: S | comment | pi | CName | 'add-attribute' |
                                                               'add-xml-base' | 'choose' | 'compare' | 'count' |
                                                               'delete' | 'directory-list' | 'documentation' | 'error' |
                                                               'escape-markup' | 'exec' | 'filter' | 'for-each' |
                                                               'group' | 'hash' | 'http-request' | 'identity' |
                                                               'insert' | 'label-elements' | 'load' |
                                                               'make-absolute-uris' | 'namespace-rename' | 'otherwise' |
                                                               'pack' | 'parameters' | 'pipeinfo' | 'rename' |
                                                               'replace' | 'set-attributes' | 'sink' |
                                                               'split-sequence' | 'store' | 'string-replace' | 'try' |
                                                               'unescape-markup' | 'unwrap' | 'uuid' |
                                                               'validate-with-relax-ng' | 'validate-with-schematron' |
                                                               'validate-with-xml-schema' | 'variable' | 'viewport' |
                                                               'when' | 'wrap' | 'wrap-sequence' |
                                                               'www-form-urldecode' | 'www-form-urlencode' |
                                                               'xinclude' | 'xquery' | 'xsl-formatter' | 'xslt' | '}' :)
    return
      if ($state[$p:l1] = 54                                (: 'otherwise' :)
       or $state[$p:l1] = 80                                (: 'when' :)
       or $state[$p:l1] = 95) then                          (: '}' :)
        $state
      else
        p:parse-subpipeline-1($input, $state)
};

(:~
 : Parse subpipeline.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-subpipeline($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-subpipeline-1($input, $state)
  return p:reduce($state, "subpipeline", $count)
};

(:~
 : Parse imports.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-imports($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(38, $input, $state)                 (: 'import' :)
  let $state := p:lookahead1W(7, $input, $state)            (: S | quotedstr :)
  let $state := p:shift(5, $input, $state)                  (: quotedstr :)
  return p:reduce($state, "imports", $count)
};

(:~
 : Parse named.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-named($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(48, $input, $state)                 (: 'named' :)
  let $state := p:lookahead1W(7, $input, $state)            (: S | quotedstr :)
  let $state := p:shift(5, $input, $state)                  (: quotedstr :)
  return p:reduce($state, "named", $count)
};

(:~
 : Parse pipeline.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-pipeline($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(59, $input, $state)                 (: 'pipeline' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S | 'named' | 'with' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 48) then                       (: 'named' :)
      let $state := p:parse-named($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(23, $input, $state)           (: S | 'with' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 81) then                       (: 'with' :)
      let $state := p:parse-withExtra($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(5, $input, $state)            (: EPSILON | S :)
  let $state := p:parse-pipelineBody($input, $state)
  return p:reduce($state, "pipeline", $count)
};

(:~
 : Parse serialization.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-serialization($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(63, $input, $state)                 (: 'serialization' :)
  let $state := p:lookahead1W(7, $input, $state)            (: S | quotedstr :)
  let $state := p:shift(5, $input, $state)                  (: quotedstr :)
  let $state := p:lookahead1W(55, $input, $state)           (: S | comment | pi | CName | 'add-attribute' |
                                                               'add-xml-base' | 'choose' | 'compare' | 'count' |
                                                               'declare-step' | 'delete' | 'directory-list' |
                                                               'documentation' | 'error' | 'escape-markup' | 'exec' |
                                                               'filter' | 'for-each' | 'group' | 'hash' |
                                                               'http-request' | 'identity' | 'import' | 'input' |
                                                               'insert' | 'label-elements' | 'load' | 'log' |
                                                               'make-absolute-uris' | 'namespace-rename' | 'option' |
                                                               'output' | 'pack' | 'parameters' | 'pipeinfo' |
                                                               'pipeline' | 'rename' | 'replace' | 'required' |
                                                               'serialization' | 'set-attributes' | 'sink' |
                                                               'split-sequence' | 'store' | 'string-replace' | 'try' |
                                                               'unescape-markup' | 'unwrap' | 'uuid' |
                                                               'validate-with-relax-ng' | 'validate-with-schematron' |
                                                               'validate-with-xml-schema' | 'variable' | 'viewport' |
                                                               'with' | 'wrap' | 'wrap-sequence' |
                                                               'www-form-urldecode' | 'www-form-urlencode' |
                                                               'xinclude' | 'xquery' | 'xsl-formatter' | 'xslt' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 81) then                       (: 'with' :)
      let $state := p:parse-withExtra($input, $state)
      return $state
    else
      $state
  return p:reduce($state, "serialization", $count)
};

(:~
 : Parse log.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-log($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(46, $input, $state)                 (: 'log' :)
  let $state := p:lookahead1W(7, $input, $state)            (: S | quotedstr :)
  let $state := p:shift(5, $input, $state)                  (: quotedstr :)
  let $state := p:lookahead1W(15, $input, $state)           (: S | 'to' :)
  let $state := p:shift(69, $input, $state)                 (: 'to' :)
  let $state := p:lookahead1W(7, $input, $state)            (: S | quotedstr :)
  let $state := p:shift(5, $input, $state)                  (: quotedstr :)
  return p:reduce($state, "log", $count)
};

(:~
 : Parse option.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-option($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 62) then                            (: 'required' :)
      let $state := p:shift(62, $input, $state)             (: 'required' :)
      let $state := p:lookahead1W(14, $input, $state)       (: S | 'option' :)
      let $state := p:shift(53, $input, $state)             (: 'option' :)
      let $state := p:lookahead1W(9, $input, $state)        (: S | QName :)
      let $state := p:shift(8, $input, $state)              (: QName :)
      let $state := p:lookahead1W(55, $input, $state)       (: S | comment | pi | CName | 'add-attribute' |
                                                               'add-xml-base' | 'choose' | 'compare' | 'count' |
                                                               'declare-step' | 'delete' | 'directory-list' |
                                                               'documentation' | 'error' | 'escape-markup' | 'exec' |
                                                               'filter' | 'for-each' | 'group' | 'hash' |
                                                               'http-request' | 'identity' | 'import' | 'input' |
                                                               'insert' | 'label-elements' | 'load' | 'log' |
                                                               'make-absolute-uris' | 'namespace-rename' | 'option' |
                                                               'output' | 'pack' | 'parameters' | 'pipeinfo' |
                                                               'pipeline' | 'rename' | 'replace' | 'required' |
                                                               'serialization' | 'set-attributes' | 'sink' |
                                                               'split-sequence' | 'store' | 'string-replace' | 'try' |
                                                               'unescape-markup' | 'unwrap' | 'uuid' |
                                                               'validate-with-relax-ng' | 'validate-with-schematron' |
                                                               'validate-with-xml-schema' | 'variable' | 'viewport' |
                                                               'with' | 'wrap' | 'wrap-sequence' |
                                                               'www-form-urldecode' | 'www-form-urlencode' |
                                                               'xinclude' | 'xquery' | 'xsl-formatter' | 'xslt' | '}' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 81) then                   (: 'with' :)
          let $state := p:parse-withExtra($input, $state)
          return $state
        else
          $state
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(53, $input, $state)             (: 'option' :)
      let $state := p:lookahead1W(9, $input, $state)        (: S | QName :)
      let $state := p:shift(8, $input, $state)              (: QName :)
      let $state := p:lookahead1W(55, $input, $state)       (: S | comment | pi | CName | 'add-attribute' |
                                                               'add-xml-base' | 'choose' | 'compare' | 'count' |
                                                               'declare-step' | 'delete' | 'directory-list' |
                                                               'documentation' | 'error' | 'escape-markup' | 'exec' |
                                                               'filter' | 'for-each' | 'group' | 'hash' |
                                                               'http-request' | 'identity' | 'import' | 'input' |
                                                               'insert' | 'label-elements' | 'load' | 'log' |
                                                               'make-absolute-uris' | 'namespace-rename' | 'option' |
                                                               'output' | 'pack' | 'parameters' | 'pipeinfo' |
                                                               'pipeline' | 'rename' | 'replace' | 'required' |
                                                               'serialization' | 'set-attributes' | 'sink' |
                                                               'split-sequence' | 'store' | 'string-replace' | 'try' |
                                                               'unescape-markup' | 'unwrap' | 'uuid' |
                                                               'validate-with-relax-ng' | 'validate-with-schematron' |
                                                               'validate-with-xml-schema' | 'variable' | 'viewport' |
                                                               'with' | 'wrap' | 'wrap-sequence' |
                                                               'www-form-urldecode' | 'www-form-urlencode' |
                                                               'xinclude' | 'xquery' | 'xsl-formatter' | 'xslt' | '}' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 81) then                   (: 'with' :)
          let $state := p:parse-withExtra($input, $state)
          return $state
        else
          $state
      return $state
  return p:reduce($state, "option", $count)
};

(:~
 : Parse the 1st loop of production output (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-output-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(33, $input, $state)         (: S | comment | pi | quotedstr | 'data' | 'document' |
                                                               'empty' | 'inline' | '}' :)
    return
      if ($state[$p:l1] = 95) then                          (: '}' :)
        $state
      else
        let $state := p:parse-binding($input, $state)
        return p:parse-output-1($input, $state)
};

(:~
 : Parse output.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-output($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(55, $input, $state)                 (: 'output' :)
  let $state := p:lookahead1W(7, $input, $state)            (: S | quotedstr :)
  let $state := p:shift(5, $input, $state)                  (: quotedstr :)
  let $state := p:lookahead1W(59, $input, $state)           (: S | comment | pi | CName | 'add-attribute' |
                                                               'add-xml-base' | 'choose' | 'compare' | 'count' |
                                                               'declare-step' | 'delete' | 'directory-list' |
                                                               'documentation' | 'error' | 'escape-markup' | 'exec' |
                                                               'filter' | 'for-each' | 'group' | 'hash' |
                                                               'http-request' | 'identity' | 'import' | 'input' |
                                                               'insert' | 'iteration-source' | 'label-elements' |
                                                               'load' | 'log' | 'make-absolute-uris' |
                                                               'namespace-rename' | 'option' | 'output' | 'pack' |
                                                               'parameters' | 'pipeinfo' | 'pipeline' | 'rename' |
                                                               'replace' | 'required' | 'serialization' |
                                                               'set-attributes' | 'sink' | 'split-sequence' | 'store' |
                                                               'string-replace' | 'try' | 'unescape-markup' | 'unwrap' |
                                                               'uuid' | 'validate-with-relax-ng' |
                                                               'validate-with-schematron' | 'validate-with-xml-schema' |
                                                               'variable' | 'viewport' | 'viewport-source' | 'with' |
                                                               'wrap' | 'wrap-sequence' | 'www-form-urldecode' |
                                                               'www-form-urlencode' | 'xinclude' | 'xpath-context' |
                                                               'xquery' | 'xsl-formatter' | 'xslt' | '{' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 81) then                       (: 'with' :)
      let $state := p:parse-withExtra($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(57, $input, $state)           (: S | comment | pi | CName | 'add-attribute' |
                                                               'add-xml-base' | 'choose' | 'compare' | 'count' |
                                                               'declare-step' | 'delete' | 'directory-list' |
                                                               'documentation' | 'error' | 'escape-markup' | 'exec' |
                                                               'filter' | 'for-each' | 'group' | 'hash' |
                                                               'http-request' | 'identity' | 'import' | 'input' |
                                                               'insert' | 'iteration-source' | 'label-elements' |
                                                               'load' | 'log' | 'make-absolute-uris' |
                                                               'namespace-rename' | 'option' | 'output' | 'pack' |
                                                               'parameters' | 'pipeinfo' | 'pipeline' | 'rename' |
                                                               'replace' | 'required' | 'serialization' |
                                                               'set-attributes' | 'sink' | 'split-sequence' | 'store' |
                                                               'string-replace' | 'try' | 'unescape-markup' | 'unwrap' |
                                                               'uuid' | 'validate-with-relax-ng' |
                                                               'validate-with-schematron' | 'validate-with-xml-schema' |
                                                               'variable' | 'viewport' | 'viewport-source' | 'wrap' |
                                                               'wrap-sequence' | 'www-form-urldecode' |
                                                               'www-form-urlencode' | 'xinclude' | 'xpath-context' |
                                                               'xquery' | 'xsl-formatter' | 'xslt' | '{' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 94) then                       (: '{' :)
      let $state := p:shift(94, $input, $state)             (: '{' :)
      let $state := p:parse-output-1($input, $state)
      let $state := p:shift(95, $input, $state)             (: '}' :)
      return $state
    else
      $state
  return p:reduce($state, "output", $count)
};

(:~
 : Parse the 1st loop of production inlineXML (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-inlineXML-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(20, $input, $state)         (: S | Char | ']]>' :)
    return
      if ($state[$p:l1] != 9) then                          (: Char :)
        $state
      else
        let $state := p:shift(9, $input, $state)            (: Char :)
        return p:parse-inlineXML-1($input, $state)
};

(:~
 : Parse inlineXML.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-inlineXML($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(1, $input, $state)             (: '<![XML[' :)
  let $state := p:shift(12, $input, $state)                 (: '<![XML[' :)
  let $state := p:parse-inlineXML-1($input, $state)
  let $state := p:shift(14, $input, $state)                 (: ']]>' :)
  return p:reduce($state, "inlineXML", $count)
};

(:~
 : Parse inlineBinding.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-inlineBinding($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(39, $input, $state)                 (: 'inline' :)
  let $state := p:lookahead1W(21, $input, $state)           (: S | '<![XML[' | 'with' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 81) then                       (: 'with' :)
      let $state := p:parse-withExtra($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(5, $input, $state)            (: EPSILON | S :)
  let $state := p:parse-inlineXML($input, $state)
  return p:reduce($state, "inlineBinding", $count)
};

(:~
 : Parse pipeBinding.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-pipeBinding($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(5, $input, $state)                  (: quotedstr :)
  let $state := p:lookahead1W(13, $input, $state)           (: S | 'on' :)
  let $state := p:shift(52, $input, $state)                 (: 'on' :)
  let $state := p:lookahead1W(7, $input, $state)            (: S | quotedstr :)
  let $state := p:shift(5, $input, $state)                  (: quotedstr :)
  let $state := p:lookahead1W(35, $input, $state)           (: S | comment | pi | quotedstr | 'data' | 'document' |
                                                               'empty' | 'inline' | 'namespaces' | 'with' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 81) then                       (: 'with' :)
      let $state := p:parse-withExtra($input, $state)
      return $state
    else
      $state
  return p:reduce($state, "pipeBinding", $count)
};

(:~
 : Parse dataBinding.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-dataBinding($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(21, $input, $state)                 (: 'data' :)
  let $state := p:lookahead1W(7, $input, $state)            (: S | quotedstr :)
  let $state := p:shift(5, $input, $state)                  (: quotedstr :)
  let $state := p:lookahead1W(35, $input, $state)           (: S | comment | pi | quotedstr | 'data' | 'document' |
                                                               'empty' | 'inline' | 'namespaces' | 'with' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 81) then                       (: 'with' :)
      let $state := p:parse-withExtra($input, $state)
      return $state
    else
      $state
  return p:reduce($state, "dataBinding", $count)
};

(:~
 : Parse documentBinding.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-documentBinding($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(26, $input, $state)                 (: 'document' :)
  let $state := p:lookahead1W(7, $input, $state)            (: S | quotedstr :)
  let $state := p:shift(5, $input, $state)                  (: quotedstr :)
  let $state := p:lookahead1W(35, $input, $state)           (: S | comment | pi | quotedstr | 'data' | 'document' |
                                                               'empty' | 'inline' | 'namespaces' | 'with' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 81) then                       (: 'with' :)
      let $state := p:parse-withExtra($input, $state)
      return $state
    else
      $state
  return p:reduce($state, "documentBinding", $count)
};

(:~
 : Parse emptyBinding.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-emptyBinding($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(28, $input, $state)                 (: 'empty' :)
  let $state := p:lookahead1W(35, $input, $state)           (: S | comment | pi | quotedstr | 'data' | 'document' |
                                                               'empty' | 'inline' | 'namespaces' | 'with' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 81) then                       (: 'with' :)
      let $state := p:parse-withExtra($input, $state)
      return $state
    else
      $state
  return p:reduce($state, "emptyBinding", $count)
};

(:~
 : Parse the 1st loop of production binding (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-binding-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 3                                  (: comment :)
    and $state[$p:l1] != 4) then                            (: pi :)
      $state
    else
      let $state :=
        if ($state[$p:l1] = 3) then                         (: comment :)
          let $state := p:shift(3, $input, $state)          (: comment :)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:shift(4, $input, $state)          (: pi :)
          return $state
      return p:parse-binding-1($input, $state)
};

(:~
 : Parse binding.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-binding($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-binding-1($input, $state)
  let $state :=
    if ($state[$p:l1] = 28) then                            (: 'empty' :)
      let $state := p:parse-emptyBinding($input, $state)
      return $state
    else if ($state[$p:l1] = 26) then                       (: 'document' :)
      let $state := p:parse-documentBinding($input, $state)
      return $state
    else if ($state[$p:l1] = 21) then                       (: 'data' :)
      let $state := p:parse-dataBinding($input, $state)
      return $state
    else if ($state[$p:l1] = 5) then                        (: quotedstr :)
      let $state := p:parse-pipeBinding($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-inlineBinding($input, $state)
      return $state
  return p:reduce($state, "binding", $count)
};

(:~
 : Parse the 1st loop of production input (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-input-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(33, $input, $state)         (: S | comment | pi | quotedstr | 'data' | 'document' |
                                                               'empty' | 'inline' | '}' :)
    return
      if ($state[$p:l1] = 95) then                          (: '}' :)
        $state
      else
        let $state := p:parse-binding($input, $state)
        return p:parse-input-1($input, $state)
};

(:~
 : Parse input.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-input($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(40, $input, $state)                 (: 'input' :)
  let $state := p:lookahead1W(7, $input, $state)            (: S | quotedstr :)
  let $state := p:shift(5, $input, $state)                  (: quotedstr :)
  let $state := p:lookahead1W(58, $input, $state)           (: S | comment | pi | CName | 'add-attribute' |
                                                               'add-xml-base' | 'choose' | 'compare' | 'count' |
                                                               'declare-step' | 'delete' | 'directory-list' |
                                                               'documentation' | 'error' | 'escape-markup' | 'exec' |
                                                               'filter' | 'for-each' | 'group' | 'hash' |
                                                               'http-request' | 'identity' | 'import' | 'input' |
                                                               'insert' | 'label-elements' | 'load' | 'log' |
                                                               'make-absolute-uris' | 'namespace-rename' | 'option' |
                                                               'output' | 'pack' | 'parameters' | 'pipeinfo' |
                                                               'pipeline' | 'rename' | 'replace' | 'required' |
                                                               'serialization' | 'set-attributes' | 'sink' |
                                                               'split-sequence' | 'store' | 'string-replace' | 'try' |
                                                               'unescape-markup' | 'unwrap' | 'uuid' |
                                                               'validate-with-relax-ng' | 'validate-with-schematron' |
                                                               'validate-with-xml-schema' | 'variable' | 'viewport' |
                                                               'with' | 'with-option' | 'with-param' | 'wrap' |
                                                               'wrap-sequence' | 'www-form-urldecode' |
                                                               'www-form-urlencode' | 'xinclude' | 'xquery' |
                                                               'xsl-formatter' | 'xslt' | '{' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 81) then                       (: 'with' :)
      let $state := p:parse-withExtra($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(56, $input, $state)           (: S | comment | pi | CName | 'add-attribute' |
                                                               'add-xml-base' | 'choose' | 'compare' | 'count' |
                                                               'declare-step' | 'delete' | 'directory-list' |
                                                               'documentation' | 'error' | 'escape-markup' | 'exec' |
                                                               'filter' | 'for-each' | 'group' | 'hash' |
                                                               'http-request' | 'identity' | 'import' | 'input' |
                                                               'insert' | 'label-elements' | 'load' | 'log' |
                                                               'make-absolute-uris' | 'namespace-rename' | 'option' |
                                                               'output' | 'pack' | 'parameters' | 'pipeinfo' |
                                                               'pipeline' | 'rename' | 'replace' | 'required' |
                                                               'serialization' | 'set-attributes' | 'sink' |
                                                               'split-sequence' | 'store' | 'string-replace' | 'try' |
                                                               'unescape-markup' | 'unwrap' | 'uuid' |
                                                               'validate-with-relax-ng' | 'validate-with-schematron' |
                                                               'validate-with-xml-schema' | 'variable' | 'viewport' |
                                                               'with-option' | 'with-param' | 'wrap' | 'wrap-sequence' |
                                                               'www-form-urldecode' | 'www-form-urlencode' |
                                                               'xinclude' | 'xquery' | 'xsl-formatter' | 'xslt' | '{' |
                                                               '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 94) then                       (: '{' :)
      let $state := p:shift(94, $input, $state)             (: '{' :)
      let $state := p:parse-input-1($input, $state)
      let $state := p:shift(95, $input, $state)             (: '}' :)
      return $state
    else
      $state
  return p:reduce($state, "input", $count)
};

(:~
 : Parse the 1st loop of production pipelineBody (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-pipelineBody-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(54, $input, $state)         (: S | comment | pi | CName | 'add-attribute' |
                                                               'add-xml-base' | 'choose' | 'compare' | 'count' |
                                                               'declare-step' | 'delete' | 'directory-list' |
                                                               'documentation' | 'error' | 'escape-markup' | 'exec' |
                                                               'filter' | 'for-each' | 'group' | 'hash' |
                                                               'http-request' | 'identity' | 'import' | 'input' |
                                                               'insert' | 'label-elements' | 'load' | 'log' |
                                                               'make-absolute-uris' | 'namespace-rename' | 'option' |
                                                               'output' | 'pack' | 'parameters' | 'pipeinfo' |
                                                               'pipeline' | 'rename' | 'replace' | 'required' |
                                                               'serialization' | 'set-attributes' | 'sink' |
                                                               'split-sequence' | 'store' | 'string-replace' | 'try' |
                                                               'unescape-markup' | 'unwrap' | 'uuid' |
                                                               'validate-with-relax-ng' | 'validate-with-schematron' |
                                                               'validate-with-xml-schema' | 'variable' | 'viewport' |
                                                               'wrap' | 'wrap-sequence' | 'www-form-urldecode' |
                                                               'www-form-urlencode' | 'xinclude' | 'xquery' |
                                                               'xsl-formatter' | 'xslt' | '}' :)
    return
      if ($state[$p:l1] != 40                               (: 'input' :)
      and $state[$p:l1] != 46                               (: 'log' :)
      and $state[$p:l1] != 53                               (: 'option' :)
      and $state[$p:l1] != 55                               (: 'output' :)
      and $state[$p:l1] != 62                               (: 'required' :)
      and $state[$p:l1] != 63) then                         (: 'serialization' :)
        $state
      else
        let $state :=
          if ($state[$p:l1] = 40) then                      (: 'input' :)
            let $state := p:parse-input($input, $state)
            return $state
          else if ($state[$p:l1] = 55) then                 (: 'output' :)
            let $state := p:parse-output($input, $state)
            return $state
          else if ($state[$p:l1] = 46) then                 (: 'log' :)
            let $state := p:parse-log($input, $state)
            return $state
          else if ($state[$p:l1] = 63) then                 (: 'serialization' :)
            let $state := p:parse-serialization($input, $state)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:parse-option($input, $state)
            return $state
        return p:parse-pipelineBody-1($input, $state)
};

(:~
 : Parse the 2nd loop of production pipelineBody (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-pipelineBody-2($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    if ($state[$p:l1] != 22                                 (: 'declare-step' :)
    and $state[$p:l1] != 38                                 (: 'import' :)
    and $state[$p:l1] != 59) then                           (: 'pipeline' :)
      $state
    else
      let $state :=
        if ($state[$p:l1] = 22) then                        (: 'declare-step' :)
          let $state := p:parse-declareStep($input, $state)
          return $state
        else if ($state[$p:l1] = 59) then                   (: 'pipeline' :)
          let $state := p:parse-pipeline($input, $state)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:parse-imports($input, $state)
          return $state
      return p:parse-pipelineBody-2($input, $state)
};

(:~
 : Parse pipelineBody.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-pipelineBody($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(4, $input, $state)             (: '{' :)
  let $state := p:shift(94, $input, $state)                 (: '{' :)
  let $state := p:parse-pipelineBody-1($input, $state)
  let $state := p:parse-pipelineBody-2($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 95) then                      (: '}' :)
      let $state := p:parse-subpipeline($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(17, $input, $state)           (: S | '}' :)
  let $state := p:shift(95, $input, $state)                 (: '}' :)
  return p:reduce($state, "pipelineBody", $count)
};

(:~
 : Parse attr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-attr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(0, $input, $state)             (: QName :)
  let $state := p:shift(8, $input, $state)                  (: QName :)
  let $state := p:lookahead1W(11, $input, $state)           (: S | '=' :)
  let $state := p:shift(13, $input, $state)                 (: '=' :)
  let $state := p:lookahead1W(19, $input, $state)           (: S | quotedstr | QName :)
  let $state :=
    if ($state[$p:l1] = 8) then                             (: QName :)
      let $state := p:shift(8, $input, $state)              (: QName :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(5, $input, $state)              (: quotedstr :)
      return $state
  return p:reduce($state, "attr", $count)
};

(:~
 : Parse the 1st loop of production withExtra (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-withExtra-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(60, $input, $state)         (: S | comment | pi | quotedstr | CName | ',' | '<![XML[' |
                                                               'add-attribute' | 'add-xml-base' | 'choose' | 'compare' |
                                                               'count' | 'data' | 'declare-step' | 'delete' |
                                                               'directory-list' | 'document' | 'documentation' |
                                                               'empty' | 'error' | 'escape-markup' | 'exec' | 'filter' |
                                                               'for-each' | 'group' | 'hash' | 'http-request' |
                                                               'identity' | 'import' | 'inline' | 'input' | 'insert' |
                                                               'iteration-source' | 'label-elements' | 'load' | 'log' |
                                                               'make-absolute-uris' | 'namespace-rename' |
                                                               'namespaces' | 'option' | 'otherwise' | 'output' |
                                                               'pack' | 'parameters' | 'pipeinfo' | 'pipeline' |
                                                               'rename' | 'replace' | 'required' | 'serialization' |
                                                               'set-attributes' | 'sink' | 'split-sequence' | 'store' |
                                                               'string-replace' | 'try' | 'unescape-markup' | 'unwrap' |
                                                               'uuid' | 'validate-with-relax-ng' |
                                                               'validate-with-schematron' | 'validate-with-xml-schema' |
                                                               'variable' | 'viewport' | 'viewport-source' | 'when' |
                                                               'with-option' | 'with-param' | 'wrap' | 'wrap-sequence' |
                                                               'www-form-urldecode' | 'www-form-urlencode' |
                                                               'xinclude' | 'xpath-context' | 'xquery' |
                                                               'xsl-formatter' | 'xslt' | '{' | '}' :)
    return
      if ($state[$p:l1] != 10) then                         (: ',' :)
        $state
      else
        let $state := p:shift(10, $input, $state)           (: ',' :)
        let $state := p:lookahead1W(5, $input, $state)      (: EPSILON | S :)
        let $state := p:parse-attr($input, $state)
        return p:parse-withExtra-1($input, $state)
};

(:~
 : Parse withExtra.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-withExtra($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(81, $input, $state)                 (: 'with' :)
  let $state := p:lookahead1W(5, $input, $state)            (: EPSILON | S :)
  let $state := p:parse-attr($input, $state)
  let $state := p:parse-withExtra-1($input, $state)
  return p:reduce($state, "withExtra", $count)
};

(:~
 : Parse stepName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-stepName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(48, $input, $state)                 (: 'named' :)
  let $state := p:lookahead1W(7, $input, $state)            (: S | quotedstr :)
  let $state := p:shift(5, $input, $state)                  (: quotedstr :)
  return p:reduce($state, "stepName", $count)
};

(:~
 : Parse declareStep.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-declareStep($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(22, $input, $state)                 (: 'declare-step' :)
  let $state := p:lookahead1W(24, $input, $state)           (: S | 'named' | 'with' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 48) then                       (: 'named' :)
      let $state := p:parse-stepName($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(23, $input, $state)           (: S | 'with' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 81) then                       (: 'with' :)
      let $state := p:parse-withExtra($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(5, $input, $state)            (: EPSILON | S :)
  let $state := p:parse-pipelineBody($input, $state)
  return p:reduce($state, "declareStep", $count)
};

(:~
 : Parse prefix.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-prefix($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(6, $input, $state)                  (: NCName :)
  return p:reduce($state, "prefix", $count)
};

(:~
 : Parse namespace.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-namespace($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(18, $input, $state)            (: 'default' | 'namespace' :)
  let $state :=
    if ($state[$p:l1] = 49) then                            (: 'namespace' :)
      let $state := p:shift(49, $input, $state)             (: 'namespace' :)
      let $state := p:lookahead1W(8, $input, $state)        (: S | NCName :)
      let $state := p:parse-prefix($input, $state)
      let $state := p:lookahead1W(11, $input, $state)       (: S | '=' :)
      let $state := p:shift(13, $input, $state)             (: '=' :)
      let $state := p:lookahead1W(7, $input, $state)        (: S | quotedstr :)
      let $state := p:shift(5, $input, $state)              (: quotedstr :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(23, $input, $state)             (: 'default' :)
      let $state := p:lookahead1W(12, $input, $state)       (: S | 'namespace' :)
      let $state := p:shift(49, $input, $state)             (: 'namespace' :)
      let $state := p:lookahead1W(11, $input, $state)       (: S | '=' :)
      let $state := p:shift(13, $input, $state)             (: '=' :)
      let $state := p:lookahead1W(7, $input, $state)        (: S | quotedstr :)
      let $state := p:shift(5, $input, $state)              (: quotedstr :)
      return $state
  return p:reduce($state, "namespace", $count)
};

(:~
 : Parse version.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-version($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(11, $input, $state)                 (: '1.0' :)
  return p:reduce($state, "version", $count)
};

(:~
 : Parse xpcMarker.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-xpcMarker($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(3, $input, $state)             (: 'xproc' :)
  let $state := p:shift(90, $input, $state)                 (: 'xproc' :)
  let $state := p:lookahead1W(10, $input, $state)           (: S | '1.0' :)
  let $state := p:parse-version($input, $state)
  return p:reduce($state, "xpcMarker", $count)
};

(:~
 : Parse the 1st loop of production document (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-document-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(28, $input, $state)         (: S | 'declare-step' | 'default' | 'library' |
                                                               'namespace' | 'pipeline' :)
    return
      if ($state[$p:l1] != 23                               (: 'default' :)
      and $state[$p:l1] != 49) then                         (: 'namespace' :)
        $state
      else
        let $state := p:parse-namespace($input, $state)
        return p:parse-document-1($input, $state)
};

(:~
 : Parse document.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-document($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1W(5, $input, $state)            (: EPSILON | S :)
  let $state := p:parse-xpcMarker($input, $state)
  let $state := p:parse-document-1($input, $state)
  let $state :=
    if ($state[$p:l1] = 22) then                            (: 'declare-step' :)
      let $state := p:parse-declareStep($input, $state)
      return $state
    else if ($state[$p:l1] = 59) then                       (: 'pipeline' :)
      let $state := p:parse-pipeline($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-library($input, $state)
      return $state
  let $state := p:lookahead1W(6, $input, $state)            (: S | EOF :)
  let $state := p:shift(2, $input, $state)                  (: EOF :)
  return p:reduce($state, "document", $count)
};

(:~
 : Parse start symbol document from given string.
 :
 : @param $s the string to be parsed.
 : @return the result as generated by parser actions.
 :)
declare function p:parse-document($s as xs:string) as item()*
{
  let $state := p:parse-document($s, (0, 1, 1, 0, 1, 0, false()))
  let $error := $state[$p:error]
  return
    if ($error) then
      element ERROR {$error/@*, p:error-message($s, $error)}
    else
      subsequence($state, $p:result)
};

p:parse-document(string(.))

