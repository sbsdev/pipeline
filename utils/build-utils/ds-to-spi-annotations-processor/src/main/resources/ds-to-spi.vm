/***************************************************************/
/* This class was generated by ds-to-spi-annotations-processor */
/***************************************************************/

#if( ${component.packageName} )
package ${component.packageName};

#end
public class ${component.spiClassName}
       extends ${component.qualifiedClassName}
       implements org.daisy.common.spi.ServiceWithProperties
#if( ${component.immediate} )
                , org.daisy.common.spi.CreateOnStart ## maybe this is not exactly what we want but it's close enough
#end
{
	
	private static final org.slf4j.Logger spi_log = org.slf4j.LoggerFactory.getLogger(${component.spiClassName}.class);
	
	private final java.util.Map spi_props;
	
	public ${component.spiClassName}() {
		super();
		spi_log.trace("Creating ${component.className}");
		spi_props = new java.util.HashMap();
		spi_props.put("component.name", "${component.name}");
#foreach($property in ${component.properties})
		spi_props.put(${property.keyLiteral}, ${property.valueLiteral});
#end
#foreach($reference in ${component.references})
		{
			spi_log.trace("Binding ${reference.service} services...");
			// cardinality: ${reference.cardinality}
#if( ${reference.cardinality} == "1..1" )
			int minRef = 1;
			int maxRef = 1;
#elseif( ${reference.cardinality} == "1..n" )
			int minRef = 1;
			int maxRef = -1;
#elseif( ${reference.cardinality} == "0..1" )
			int minRef = 0;
			int maxRef = 1;
#else
			int minRef = 0;
			int maxRef = -1;
#end
			int refCount = 0;
			try {
				java.util.Iterator<${reference.service}> services
					= org.daisy.common.spi.ServiceLoader.load(${reference.service}.class).iterator();
#if( ${reference.filter} )
				 org.osgi.framework.Filter filter = org.osgi.framework.FrameworkUtil.createFilter(${reference.filter});
#end
				while (services.hasNext()) {
					try {
						${reference.service} service = services.next();
#if( ${reference.filter} )
						if (!filter.matches(((org.daisy.common.spi.ServiceWithProperties)service).spi_getProperties())) {
							spi_log.trace("Service " + service + " does not match " + ${reference.filter});
							continue; }
#end
#if( ${reference.propertiesArgumentType} )
						${reference.propertiesArgumentType.getName()} props = new ${reference.propertiesArgumentType.getName()}();
						for (java.util.Map.Entry kv : (java.util.Set<java.util.Map.Entry>)
								((org.daisy.common.spi.ServiceWithProperties)service).spi_getProperties().entrySet()) {
							props.put(kv.getKey(), kv.getValue());
						}
						${reference.methodName}(service, props);
#else
						${reference.methodName}(service);
#end
						refCount++;
						if (maxRef > 0 && refCount == maxRef)
							break;
					} catch (Throwable e) {
						spi_log.error("Error while binding ${reference.service} service", e);
					}
				}
			} catch (Throwable e) {
				spi_log.error("Error while binding ${reference.service} services", e);
			}
			if (refCount < minRef) {
				spi_log.warn("No ${reference.service} found");
				throw new RuntimeException("No ${reference.service} found");
			} else {
				spi_log.trace("Bound " + refCount + " ${reference.service} services.");
			}
		}
#end
#if( ${component.activate} )
		spi_log.trace("Activating ${component.className}");
#if( ${component.activate.propertiesArgumentType} )
		${component.activate.propertiesArgumentType.getName()} props = new ${component.activate.propertiesArgumentType.getName()}();
		props.put("component.name", "${component.name}");
#foreach($property in ${component.properties})
		props.put(${property.keyLiteral}, ${property.valueLiteral});
#end
		${component.activate.methodName}(props);
#else
		${component.activate.methodName}();
#end
#end
	}
	
	public java.util.Map spi_getProperties() {
		return spi_props;
	}
}
